<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>impdx</title>
  
  
  <link href="https://www.impdx.vip/atom.xml" rel="self"/>
  
  <link href="https://www.impdx.vip/"/>
  <updated>2023-08-24T06:57:02.319Z</updated>
  <id>https://www.impdx.vip/</id>
  
  <author>
    <name>impdx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>攻防-harbor低版本利用</title>
    <link href="https://www.impdx.vip/posts/8b9baacf/"/>
    <id>https://www.impdx.vip/posts/8b9baacf/</id>
    <published>2023-08-24T12:42:06.000Z</published>
    <updated>2023-08-24T06:57:02.319Z</updated>
    
    <content type="html"><![CDATA[<h1>hvv-harbor低版本利用</h1><p>在攻防中，遇到直接拿poc怼，结果返回json有问题，注册失败？<br>网上大部分poc都是直接上<code>has_admin_role&quot;:true</code>，但在低版本中，user结构体中是int值，所以poc为：<code>has_admin_role&quot;:1</code></p><h1>什么是harbor</h1><blockquote><p>先了解一下harbor：Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。</p></blockquote><p>作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。</p><h1>影响范围</h1><p>Harbor1.7.6之前版本和Harbor1.8.3之前版本</p><h1>高版本漏洞</h1><ul><li>注册时加<code>has_admin_role&quot;:true</code></li></ul><p>Post 注册，抓包，post内容加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /api/users HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Length: 131</span><br><span class="line">Accept: application/json</span><br><span class="line">Origin: http://127.0.0.1</span><br><span class="line">User-Agent: Opera/9.80 (Windows NT 6.0) Presto/2.12.388 Version/12.14</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Referer: http://127.0.0.1/harbor/sign-in</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: sid=5bb9aad90164bd2ed5274edaf20f9c81</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;username&quot;:&quot;mrhonest&quot;,&quot;email&quot;:&quot;impdx@qq.com&quot;,&quot;realname&quot;:&quot;mrhonest&quot;,&quot;password&quot;:&quot;111111Aaa&quot;,&quot;comment&quot;:&quot;11111&quot;,&quot;has_admin_role&quot;:true&#125;</span><br></pre></td></tr></table></figure><h1>低版本harbor 任意管理</h1><ul><li>在hvv中发现poc返回有问题，版本为1.2.0</li><li>翻github，1.2.0为之前发布的版本，我们直接看源码分析</li></ul><blockquote><p>想一下为什么会有这个漏洞，无非是Post请求包中的has_admin_role值被接受了，没有经过校验。</p></blockquote><ul><li>那我们直接找hasadminrole，直接找user结构体(go中结构体和java的类相似)里面有啥，有啥值。 <img src="https://image.impdx.vip//blog202307222238608.png" alt=""></li></ul><p>哎？我们发现他居然不是boolean值，而是int值。那么我们想一下，在语言中，如果判断一个值为真假，就像C没boolean，那<code>int=1</code>就是真，所以我们把poc稍做修改</p><h2 id="poc">poc</h2><p>注册之后抓包，添加<code>&quot;has_admin_role&quot;:1</code>，不要直接用下面的，因为cookie不一样，建议抓包修改添加<code>&quot;has_admin_role&quot;:1</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /api/users HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Length: 131</span><br><span class="line">Accept: application/json</span><br><span class="line">Origin: http://127.0.0.1</span><br><span class="line">User-Agent: Opera/9.80 (Windows NT 6.0) Presto/2.12.388 Version/12.14</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Referer: http://127.0.0.1/harbor/sign-in</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: sid=5bb9aad90164bd2ed5274edaf20f9c81</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;username&quot;:&quot;mrhonest&quot;,&quot;email&quot;:&quot;impdx@qq.com&quot;,&quot;realname&quot;:&quot;mrhonest&quot;,&quot;password&quot;:&quot;111111Aaa&quot;,&quot;comment&quot;:&quot;11111&quot;,&quot;has_admin_role&quot;:1&#125;</span><br></pre></td></tr></table></figure><p>ok，任意用户注册成功。</p><p>利用点：可以先docker login进去，pull下docker环境找敏感信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;hvv-harbor低版本利用&lt;/h1&gt;
&lt;p&gt;在攻防中，遇到直接拿poc怼，结果返回json有问题，注册失败？&lt;br&gt;
网上大部分poc都是直接上&lt;code&gt;has_admin_role&amp;quot;:true&lt;/code&gt;，但在低版本中，user结构体中是int值，所以</summary>
      
    
    
    
    
    <category term="攻防" scheme="https://www.impdx.vip/tags/%E6%94%BB%E9%98%B2/"/>
    
  </entry>
  
  <entry>
    <title>国行 S9+ (SM-G9650) 刷入 TWRP + Mgasik</title>
    <link href="https://www.impdx.vip/posts/c659/"/>
    <id>https://www.impdx.vip/posts/c659/</id>
    <published>2023-05-17T08:25:51.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<h1>国行 S9+ (SM-G9650) 刷入 TWRP + Mgasik</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">本文记录impdx遇到的问题与解决方案，其中机子是S9+，从8.0升级到了10，所以安卓中的某些机制变化了，比如，从converted 转到2SI ramdisk SAR</span><br><span class="line"></span><br><span class="line">magisk给出的方案是System-as-root，如果不加上前面步骤，会导致卡屏logo，假砖，主要思路是刷入twrp之后去解锁avb以及Vaultkeeper验证使用Multidisabler，再刷入klabit87 的内核。</span><br><span class="line"></span><br><span class="line">原理参考xda大神https://forum.xda-developers.com/t/pie-10-11-system-as-root-multidisabler-disables-encryption-vaultkeeper-auto-flash-of-stock-recovery-proca-wsm-cass-etc.3919714 在下其实不清楚到底是vaultkeepr/Process authentication (a.k.a. proca)/Stock recovery auto-restoration哪一个在启作用，因为途中尝试已经把avb禁用了。但可以用大神的脚本一键关闭</span><br><span class="line"></span><br><span class="line">以及https://forum.xda-developers.com/t/kernel-q-g9650-g9600-klabit-kernel.3900816/</span><br><span class="line"> klabit87大神的内核</span><br><span class="line"></span><br><span class="line">通过刷入maisk.zip获取的，官方推荐用修改AP_....tar.md5使用odin3刷入，但实测刷入修补过的tar有概率卡第一屏logo，卡刷则无问题。</span><br><span class="line"></span><br><span class="line">其实仔细看magisk文档已经写的很清楚，在bootload那边有介绍解锁记得把vaultkeepr禁用。</span><br></pre></td></tr></table></figure><h1>下载必须资料</h1><h2 id="原始链接（国内可能打不开）">原始链接（国内可能打不开）</h2><ul><li>TWRP : <a href="https://www.androidfilehost.com/?w=files&amp;flid=329265">https://www.androidfilehost.com/?w=files&amp;flid=329265</a></li><li>klabit87 kernel 带magisk:<a href="https://github.com/klabit87/android_kernel_samsung_sdm845/releases/download/V6.5/g9650_klabit_gsi_V6.5.zip">https://github.com/klabit87/android_kernel_samsung_sdm845/releases/download/V6.5/g9650_klabit_gsi_V6.5.zip</a></li><li>magisk:<a href="https://github.com/topjohnwu/Magisk/releases/download/v26.1/Magisk-v26.1.apk">https://github.com/topjohnwu/Magisk/releases/download/v26.1/Magisk-v26.1.apk</a></li><li>odin3:<a href="https://odindownloader.com/wp-content/uploads/odin3_v3.14.4.zip">https://odindownloader.com/wp-content/uploads/odin3_v3.14.4.zip</a></li><li>三星usb驱动:<a href="https://developer.samsung.com/sdp/file/2ad30860-0932-44e3-bf63-765a5cfa1010">https://developer.samsung.com/sdp/file/2ad30860-0932-44e3-bf63-765a5cfa1010</a>  官网：<a href="https://developer.samsung.com/android-usb-driver">https://developer.samsung.com/android-usb-driver</a></li><li>ROM下载器:<a href="https://samfirmtool.com/samfirm-v0-5-0">https://samfirmtool.com/samfirm-v0-5-0</a></li></ul><h2 id="蓝奏云">蓝奏云</h2><p><a href="https://wwi.lanzoup.com/b012yl25g">https://wwi.lanzoup.com/b012yl25g</a><br>密码:hmup</p><h2 id="rom-下载">rom 下载</h2><p>1.打开 SamFirm<br>2.Region为CHC，国行的意思，model就是型号，auto勾上，check update，会检查出适合的ROM包，点download下载就可以了，下载后是zip，解压一下。<br>（小知识：三星的ROM包为定制，tar.md5格式，三星无fastboot模式，准确说改为了download模式）<br><img src="https://image.impdx.vip//blog202305161738625.png" alt=""></p><h1>解锁bootload （会清除数据，记得备份）</h1><p>1.解锁bl，点开设置-关于手机-软件信息-点击编译编号5次，进入开发者设置</p><p>2.记一下，你的基带版本，比如我的是 G9650ZCS9FVA4 (后面有用)</p><p>3.找到开发者设置中的OEM解锁，直接点开，需要重启设置并清楚数据</p><p>4.完成，S9+只需要上面步骤就可以了，20年之后的还需要进入download模式长按音量上键，但S9+不需要。</p><h1>使用odin3 刷入TWRP</h1><ul><li>点开options，auto reboot取消自动重启<br><img src="https://image.impdx.vip//blog202305161748993.png" alt=""></li></ul><p>1.刷入一遍rom包，AP选带ap的，以此类推，csc选择无home</p><ul><li>如果版本一致，可以不用刷入rom，不用管userdata<br>2.单AP刷入twrp.tar包，注意格式为tar<br><img src="https://image.impdx.vip//blog202305161749582.png" alt=""></li></ul><p>3.刷入完成按住音量下+Bixby+电源键重启，黑屏一瞬间换音量上+bixby+电源键</p><p>4.点wipe -&gt; format data 输入yes，格式化data，接着重启到recovery<br><img src="https://image.impdx.vip//blog202305161800991.png" alt=""></p><p><img src="https://image.impdx.vip//blog202305161759526.png" alt=""></p><p>5.TWRP 完成！要进行下一步可以不用重启</p><h1>使用twrp旧方法刷入magisk</h1><p>1.TWRP中选择Advanced &gt; Terminal, type: <code>multidisabler</code>，可以输入mul然后按tab自动补全，回车，出现finsh就是完成</p><p><img src="https://image.impdx.vip//blog202305161800818.png" alt=""></p><p>2.点开mtp，用电脑传输g9650_klabit_gsi_V6.5.zip，magisk.zip，magisk.apk</p><p>3.点install刷入<code>g9650_klabit_gsi_V6.5.zip</code>,接着刷入magisk</p><p>4.系统中安装magisk.apk</p><p>5.会弹出提示，点确认就可以了，期间重启正常，如重启后还需点确认就点。我点了俩次magisk正常运行</p><p>6.完成</p><p>后面就可以愉快的使用lsposed了。</p><h1>总结</h1><p>三星还是比较麻烦的，其他手机一般直接解锁bootload后，可以通过fastboot直接刷入修补后的boot.img，非常方便。最近几款新的kernelsu，superkernelroot也是非常有意思。都是通过内核层面的root。其中superkernelroot值得研究一下，好似是今年刚开源不久。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;国行 S9+ (SM-G9650) 刷入 TWRP + Mgasik&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa</summary>
      
    
    
    
    <category term="教程" scheme="https://www.impdx.vip/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="维修手机" scheme="https://www.impdx.vip/tags/%E7%BB%B4%E4%BF%AE%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>学路漫漫</title>
    <link href="https://www.impdx.vip/posts/f229d4cc/"/>
    <id>https://www.impdx.vip/posts/f229d4cc/</id>
    <published>2022-10-03T12:42:06.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<p>有空就更，就更hhh。<br>有感而发，有感而发233</p><h1>0x00 前</h1><p>我，是在一个南方十八线小县城土生土长的。准确说是农村hhh，只不过后来到城里了，生活也不咋样，总体还算幸福。住过别人的储物间，也住过烈士林园旁的一间房间(真的只是一间，吃饭烧饭都在，至于厕所只能在公厕)，因它们都比较便宜。<br>记得母亲身体不好，父亲一人撑起一个家。现在想都不敢想，居然有一整间套房居住，虽然小，但足以。</p><p>小学和初中就不多过述，实际上我也忘了许多，依稀记得初中当时有幻影pin，水滴跑pin，跑包。还有一些刷钻，刷vip，刷机，各种原生rom，当时的酷安嘎嘎牛，各路大神，还在suroot的阶段，4.x，其实我还有部2.3.5的机子，那是我安卓版本最低的机子。当然还有游戏，这也导致我从不关心学习，只对科学一门感兴趣。当时好似科学单科180，我可以考150？忘了hhh。</p><p>县里只有几所高中，可惜的是，向来学习成绩不好。依稀记得当时中考有好似60%以上的同学只能去职业高中/技校/企业办高中，而我正是其中一员。</p><p>到了职高，其实与本科也无缘了，高中幸遇恩师，给我创造了很多不敢想象的条件。在职高中，我可以接触到机房，机房的还原卡，也有一天到晚研究电脑的时间，当时特别对linux感兴趣，试着arch/centos/debian/deepin,可笑的是当时我把debian听成了deepin。中途学了些python，vb，都是些变量赋值循环哈哈哈。当时我有一间小小的实验室，无聊的时候，夜自修也总是在那边捣鼓着各种各样的关于电脑的东西，还搭建了第一个博客，学会了基本的修电脑。当时就想着找个电脑店或者电脑公司，干干修电脑修手机的活，一辈子就这么过去，现在想来真是幸运。</p><p>不出意外，就要出意外，高中时病了一年。那一年是深刻的，是幸运的。本该留级，也多亏恩师照顾。最后可以顺利继续上学，继续职高考。</p><h2 id="恩师">恩师</h2><p>对于我的恩师，他姓鲍，一日为师，终身为父。当然也有其他良师益友，比如曾教我计算机理论的吕老师，是她让我可以面对台下无论多少人，都可以面不改色的说话。高中的老师，都很好，都很不错。遇到这群老师，是我的幸运。</p><p>初中也有不错的班主任，他姓方，从不放弃任何一个学生。授课同时也教我们一些做人的道理。从最差的班级，带成最好的班级。不过我则是倒数，实在是让老师们操心了。<br>初中的记忆是比较深刻的，失去过朋友，是生死离别，我们永远也不不知道意外和明天哪个会先来。甚至都没来得及打个招呼。</p><p>其实，我更愿换一种称呼，称他们为先生。他们是真正<strong>教书育人</strong>的先生。</p><h1>0x01 大专</h1><h2 id="大一">大一</h2><p>不出意外，考上了一个大专。当时想的特别简单，随便报。<br>于是乎，人生的第一所大学。<br>依稀记得，刚开学有位头发稀少的老师来跟我们说软件技术的课程定位，当时瞄了一眼杂而不精，切没有linux，顿时开怼。后来才知，这是我们当时的教学主任。<br>开学时普普通通，我一心想好好学习刚开始，追随大众潮流，却不想竞选班委一个都没选上。如此想起之前，我要搞竞赛，我要打ACM，我要当一名合格的程序员。途中认识了一位好友，虽不是本专业，但志同道合。也是后来ACM的队友。<br>于是狂学c语言，半夜和好友在校内排行榜上的一妹子刷半天榜一，可那些都是简单的水题，什么输入输出，韩信点兵罢了。学了一学期，晚上就到图书馆咖啡厅敲代码，有夜自修就在夜自修敲代码。半夜也在敲。</p><p>过了一学期，3月，是个重要的转折点。老师们开始招新，但竞赛是4.16号就开始hhh。当时有很多人报名，选拔赛，我一听说有竞赛，急忙问了工作室地点，直接把台式给搬了过去，一扔，一坐，就开始敲代码。</p><p>很遗憾，以我当时的成绩是应该不具备进入的资格。经过正常普高的学生，数学比我好的太多了，思维也比我敏捷。老师看我一天到晚，中午午休，晚上吃晚饭，下课时间都在。给了我一个名额。</p><p>进入工作室后，有俩位学长，一位是aa大三准备升本，每天我都可以看到他7:30到，晚上9点准时走。还有一位是bb学长，大二同样准备竞赛。比我可强太多了，我的队友也比我强。</p><p>时间很快，第一次竞赛依然是没有什么输出，靠着队友混了个省三。<br>竞赛就不多讲了，可以看<a href="https://www.impdx.vip/posts/8b36d450/index.html">我的竞赛之路</a></p><p>同时，舍友也发生了有趣的变化，以为A同学喜爱游戏开发，就如陈丹青所说：“喜欢游戏开发我操这拦不住的”，他就来学习C#和unity了，为啥学这俩呢，对面我看有个工作室正是unity。还有位B同学，买了几k的课学建模，想来刚好他们可以组一个队伍上去打。还有C同学，本是想着去Android竞赛，可事与愿违。于是便在专升本的道路上一路狂奔。其实我们是6人寝，还有DE同学就在摆烂了。</p><p>大一就这么过去了。</p><h2 id="大二">大二</h2><p>大二的时候刚开学，脑子一热，想起以前刷钻那时候，卧槽，我想干网络安全，我想当大黑阔，就如陈丹青所说：“喜欢当大黑阔我操这拦不住的”。泥煤的，队友给我找到了网络安全工作室，不过只有大三一人，之前也没人，也没拿过奖。比起ACM实力纵然弱了不少。但还是为了梦想，义无反顾一头脑扎进去了，10月就开赛，而我9月多刚进去。依稀记得当时一个base64-base32反复解密就有一题flag，就有一个省三。</p><p>之后我就有些飘飘自然了。<br>引用 redateam-notes</p><blockquote><p>例如会把所谓成为一名黑客想象成一种至高的事情， 觉得自己的职业和其他的职业与众<br>不同， 觉得自己选择了搞安全， 走的路子就和其他搞代码的人不一样了。<br>再加上外界电影， 电视， 国内武侠小说的渲染， 自媒体人的烘托， 来一两下还好， 来多<br>了， 妈的， 还真以为自己有点东西了。<br>这种自认为与众不同的心态， 就是外面的壳。<br>当沉浸在壳中的时候， 就像逆向的时候， od 调代码， 断点断在了壳上， 壳也做的挺好<br>的， 调了半天， 觉得自己真牛逼， 实际上壳都没脱掉， 源码都没见到。</p></blockquote><p>妈的， 还真以为自己有点东西了。这个心态是真的傻逼自大。</p><p>之后就是新生来喽，之前没有招新。这次一间间教室去串门招新。对了还有游戏开发工作室。舍友已经成功去游戏开发了，我的队友也去了，他说，我的梦想是开发游戏。梦想还是要有的，不然和咸鱼有什么区别。</p><p>同时着手工作室建设，<a href="https://www.impdx.vip/posts/e5b39ca6/index.html">搭建wiki</a><br>也有了acm的oj，ctf的ctfd。<br>至此。</p><h2 id="大三">大三</h2><p>很快就大三了，快如初中至高中，高中至大学。<br>ACM我一人，CTF我一人。便要开始升本了。<br>幸运的是，大一学弟们有很不错的苗子，比我可强太多了。<br>大三就没有什么了。</p><p>2022.10.4</p><h1>0x0F</h1><p>无论是什么时候，我都是一个追赶者，追赶者前人的脚步。打竞赛也好，学习也罢。<br>我从来不是一个优秀的人。我这人吧，可以说全是运气。运气好接触到了手机，运气好接触到了好的先生，运气好，进了竞赛，运气好，靠着队友拿了奖，又是靠这运气，拿了一些奖。</p><p>现在又在升本中挣扎，这么差的基础，其实我心里也没底，但总得学，总得往前。</p><p>从来没有准备好，也不会有准备好的时候。总得往前走。</p><p>为什么要写这篇文章？</p><ul><li>最近心境有些乱，其根本无非是时间恐慌。也有太多东西本不属于我，人贵有自知之明。</li><li>很多东西，给你这样的舞台，你也可以拥有那一切。</li><li>很多东西，写出来了，反而就像吐出一口气，身轻如燕。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有空就更，就更hhh。&lt;br&gt;
有感而发，有感而发233&lt;/p&gt;
&lt;h1&gt;0x00 前&lt;/h1&gt;
&lt;p&gt;我，是在一个南方十八线小县城土生土长的。准确说是农村hhh，只不过后来到城里了，生活也不咋样，总体还算幸福。住过别人的储物间，也住过烈士林园旁的一间房间(真的只是一间，吃</summary>
      
    
    
    
    
    <category term="自传" scheme="https://www.impdx.vip/tags/%E8%87%AA%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>为学校搭建竞赛wiki</title>
    <link href="https://www.impdx.vip/posts/e5b39ca6/"/>
    <id>https://www.impdx.vip/posts/e5b39ca6/</id>
    <published>2022-05-14T08:24:20.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<p>==123==</p><h1>起因</h1><ul><li>发现竞赛的弱校，无论是CTF/ACM亦或着是其他的竞赛。都有几个痛点<ul><li>出现人才断层，即俩三届无人可用 ^ff33c2</li><li>出现知识断层，没人也就无人传授知识点</li></ul></li><li>第一种情况我们无法避免，只能招新时扩大宣传力度。</li><li>第二种完全可以避免，如何传授知识，除了面对面。那便只有<strong>文字</strong>.</li></ul><p>突然某一天意识到有wiki的存在</p><p>那便整一个</p><h1>wiki的选择</h1><ul><li>语雀<ul><li>优点：在线，免费，美观</li><li>缺点：团队版需付费</li></ul></li><li>wiki.js<ul><li>nodejs</li><li>优点：强大，美观，权限控制严格，脱离传统文件夹结构</li><li>缺点：2h2gserver起步，</li></ul></li><li>MediaWiki<ul><li>优点：强大</li><li>缺点：折腾，太折腾</li></ul></li><li>DokuWiki<ul><li>优点：轻量化，部署快</li><li>缺点：丑，且权限不严格</li></ul></li><li>MinDoc<ul><li>优点：美观，部署快，轻量化</li><li>缺点：官网的css都失效了，权限不够严格</li></ul></li><li>BookStack<ul><li>优点：强大</li><li>缺点：功能多余，丑</li></ul></li></ul><p>还有很多不一一列举了,最终选择了<code>wiki.js</code></p><p>理由是权限严格，同时刚好wiki可以给多个工作室用。多个竞赛用来分享知识点。</p><h2 id="服务器的选择">服务器的选择</h2><ul><li>选择了海外腾讯云。搞活动便宜了一些</li><li>为何不选国内？备案太过于繁琐。</li><li>为何不选国外主机厂商？国外厂商更贵233</li></ul><h1>上线wiki.js</h1><ul><li>轻量服务器，选择的是宝塔+centos</li></ul><ol><li>首先安装docker。可参考官网docker安装教程<br><a href="https://docs.docker.com/engine/install">https://docs.docker.com/engine/install</a> 在下面有个列表，选择对应的系统，之后复制粘贴即可，这里以[centos](<a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS | Docker Documentation</a>)为例：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><p>测试docker，运行以下俩条命令，显示hello world可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><ol start="2"><li>参考官方安装指南，</li></ol><ul><li><a href="https://docs.requarks.io/install/ubuntu">安装在 Ubuntu 18.04 / 20.04 / 22.04 LTS |维基.js (requarks.io)</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Create installation directory for Wiki.js</span><br><span class="line">mkdir -p /etc/wiki</span><br><span class="line"></span><br><span class="line"># Generate DB secret</span><br><span class="line">openssl rand -base64 32 &gt; /etc/wiki/.db-secret</span><br><span class="line"></span><br><span class="line"># Create internal docker network</span><br><span class="line">docker network create wikinet</span><br><span class="line"></span><br><span class="line"># Create data volume for PostgreSQL</span><br><span class="line">docker volume create pgdata</span><br><span class="line"></span><br><span class="line"># Create the containers</span><br><span class="line">docker create --name=db -e POSTGRES_DB=wiki -e POSTGRES_USER=wiki -e POSTGRES_PASSWORD_FILE=/etc/wiki/.db-secret -v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro -v pgdata:/var/lib/postgresql/data --restart=unless-stopped -h db --network=wikinet postgres:11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker create --name=wiki -e DB_TYPE=postgres -e DB_HOST=db -e DB_PORT=5432 -e DB_PASS_FILE=/etc/wiki/.db-secret -v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro -e DB_USER=wiki -e DB_NAME=wiki -e UPGRADE_COMPANION=1 --restart=unless-stopped -h wiki --network=wikinet -p 80:3000 -p 443:3443 ghcr.io/requarks/wiki:2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker create --name=wiki-update-companion -v /var/run/docker.sock:/var/run/docker.sock:ro --restart=unless-stopped -h wiki-update-companion --network=wikinet ghcr.io/requarks/wiki-update-companion:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ufw设置一波,也可以用iptables，firewall都可以。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow http</span><br><span class="line">sudo ufw allow https</span><br><span class="line"></span><br><span class="line">sudo ufw --force enable</span><br></pre></td></tr></table></figure><ol start="3"><li>启动wiki</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start db </span><br><span class="line">docker start wiki </span><br><span class="line">docker start wiki-update-companion</span><br></pre></td></tr></table></figure><blockquote><p>这时候就可以访问了，ip直接访问，默认是只有80端口</p></blockquote><ol start="4"><li>启用https</li></ol><ul><li>这里用Let’s Encryp 来演示，还是参考官网文档</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker stop wiki</span><br><span class="line">docker rm wiki</span><br><span class="line"></span><br><span class="line">docker create --name=wiki -e LETSENCRYPT_DOMAIN=wiki.example.com -e LETSENCRYPT_EMAIL=admin@example.com -e SSL_ACTIVE=1 -e DB_TYPE=postgres -e DB_HOST=db -e DB_PORT=5432 -e DB_PASS_FILE=/etc/wiki/.db-secret -v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro -e DB_USER=wiki -e DB_NAME=wiki -e UPGRADE_COMPANION=1 --restart=unless-stopped -h wiki --network=wikinet -p 80:3000 -p 443:3443 ghcr.io/requarks/wiki:2</span><br><span class="line"></span><br><span class="line"># 注意：，将admin@example.com 换成你自己的邮箱，将wiki.example.com换成你的域名。</span><br><span class="line"></span><br><span class="line"># 最后启动即可</span><br><span class="line">docker start wiki</span><br></pre></td></tr></table></figure><blockquote><p>注: 访问需要手动加上https，如果想直接重定向，需要进wiki后台更改，有可视化GUI界面</p></blockquote><h1>后续配置</h1><ol><li>分配权限</li></ol><ul><li>需求：<ul><li>内部wiki，外部不可以访问</li><li>分ACM,CTF,游戏开发三个大类</li><li>所有人都可以查看所有文档，但只能修改自己工作室的。</li><li>需一个普通管理增加用户和分配权限</li></ul></li></ul><p>以下是权限分配</p><ul><li>关于group（组）和页面规则，可以康康<a href="https://docs.requarks.io/groups">官网的文档</a></li><li>个人理解，页面规则是组的的详细配置，具体配置。一个组里面更详细的分配，某个目录可以访问/修改，某个目录禁止访问/修改</li><li><code>w</code>:write(写入权限)   <code>r</code>：read（读取权限）</li><li>组可以定义成员的具体权限，具体可以访问/编辑哪个目录。</li><li>用户可以加入多个组，叠加权限</li></ul><blockquote><p>实现以上需求看图</p></blockquote><p><img src="https://image.impdx.vip//202205142059313.png" alt=""></p><ol start="2"><li>关于文件目录与传统目录的区别</li></ol><ul><li>愚见：不用像传统目录先创建文件夹，在创建文件。直接创建文件</li></ul><p>具体请看 <a href="https://docs.requarks.io/guide/structure">官方文档</a></p><p><img src="https://docs.requarks.io/assets/diagrams/diag-folder-structure.jpg" alt=""></p><h1>更多功能</h1><ul><li>后台具有很多功能，包括主题</li></ul><ol><li>备份</li></ol><ul><li>注意备份：只备份md文件。<ol><li>使用git进行备份。由于是docker安装，所以直接用ssh方式，私钥填入contents就行</li><li>sftp，可以备份到其他server上</li></ol></li></ul><ol start="2"><li>渲染<ol><li>支持katex，注意有小bug，遇到<code>x^&#123;x^3&#125;</code>这种情况需要改为<code>x^&#123;&#123;x^3&#125;&#125;</code>,因为wiki的多层渲染导致的历史遗留问题。</li></ol></li><li>升级<ol><li>只需在后台一键升级即可</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;==123==&lt;/p&gt;
&lt;h1&gt;起因&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;发现竞赛的弱校，无论是CTF/ACM亦或着是其他的竞赛。都有几个痛点
&lt;ul&gt;
&lt;li&gt;出现人才断层，即俩三届无人可用 ^ff33c2&lt;/li&gt;
&lt;li&gt;出现知识断层，没人也就无人传授知识点&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的竞赛之路</title>
    <link href="https://www.impdx.vip/posts/8b36d450/"/>
    <id>https://www.impdx.vip/posts/8b36d450/</id>
    <published>2022-05-08T11:50:49.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<h1>我的大学竞赛生涯</h1><ul><li>一只<code>笨鸟</code>的大专一年竞赛生涯。</li></ul><p>4月底，这次ACM打完了，竞赛生涯几乎结束了。无论是CTF还是ACM亦或着是蓝桥/信息安全管理与评估等。</p><p>身体也越来越发不舒适了，大致还需俩次小手术。</p><h2 id="0x01">0x01</h2><p>说说ACM吧，来ACM已有一年。<br>21年3月，当时听说有ACM竞赛工作室，马上就把我那台式给放在了工作室。考核时，我是最后一名卡线而进入工作室的。当时想的，就算不能打竞赛，也要学习，无论在哪里。（其实我很清楚，应该是老师给我放了点小水，不然我不可能来竞赛。）</p><p>学习了一个月，队友很给力，把签到题写完拿了一个铜。而我当时苦于dfs，为了n皇后问题学了一周也没太懂，真是蠢到家了。可奇怪的是，那一年只有一个学长和我们这支队拿了铜。后自想来，我也不过是没拿奖的水平罢了。</p><p>时隔一年，这次却没有拿奖意料之中。中途的事情，一言难尽。有主观也有客观。</p><p>我对ACM是有感情的，我看到很多强校，他们有oj，有资源，有老师，有学校的支持。我们弱校又该如何，根本无法竞争。萌发了OJ的想法，资源暂时用acwing替代，学校的支持不敢渴求。21年的学弟们也成功上线了oj，慢慢在放题目。我想，或许可以下一届举办一场ACM校赛</p><p>我的数学只有初中水平。没错，数学这种水平还敢来打竞赛，因为是弱校，也没有多少人竞争。所以重在坚持，中途有其他同学的天赋和智商都比我高，毫不夸张的说他们没有中途放弃，最终都会拿到奖。甚至我连竞赛名额都没有。</p><h2 id="0x02">0x02</h2><p>来到21年的十月份，接触到了ctf，学了一个月。写了一题签到题，依然是铜牌。<br>但ctf也是如此，我们是弱校，什么都没有。没有到什么程度么，比ACM还没有。整个学校只有大三一位学长在苦苦支撑。虽然ACM也是hh。于是看到ctfd，也有不错的学弟上线了第一款ctfd。我想，或许可以下一届举办一场CTF校赛。</p><p>弱校的资源少的可怜，学的学生也是，在我这届ACM只有包括我俩个人，CTF只有我一人。但好在现如今他们的人数在慢慢变多。</p><p>直到现在，信息安全堪堪入门罢了。当然也确定了我所热爱的职业。也算是迟来的幸运，相比于大佬们的初中开始入门信安，我却到了大二才堪堪赶上。</p><h2 id="0x03">0x03</h2><p>专升本，绕不开的话题，这个社会对于学历的歧视。毫无办法，学历洗白私以为只有考研一条路，但还需看行业。</p><p>或许以我的基础无法顺利专升本，尽力而为。有时候挺怕学的太努力把自己送进医院hh。如专升本不成，那便只有一条路，考研。</p><p>b级没过，数学初中水平。没有什么捷径，只能一步一个脚印去学。</p><p>依稀记得大型甲方如银行招聘，四年制全日制本科及以上。</p><h2 id="0x04">0x04</h2><p>我希望我的学弟们他们进来可以有好的资源，可以和那些强校正真的去较量。而不是用资源去较量。也不想他们像我一样受资源所制。也不要像我一样，走这么多弯路。如果热爱，希望你们可以尽快进入行业里。无论是信息安全还是开发，还是运维测试。</p><p>大专里，我们需保持初心。濯清涟而不妖，出淤泥而不染。即便有花花世界的各种诱惑，我们也需要沉下心来慢慢搞技术，补基础。</p><ul><li>正在考虑内部wiki平台，可以更长久的沉淀知识。</li><li>已经建成内部wiki，采用wiki.js。不得不说wiki.js是真的很强大。学弟们也很给力，俩三天传了一百多遍文章了。</li></ul><h2 id="0x05">0x05</h2><ul><li>大专里的竞赛，三等二等只需稍稍努力，沉下心来学习就行。</li><li>如果是CTF/ACM的一等，需要一定的时间沉淀和实力。（ACM可以特等可以试试区域赛，CTF可以试试西湖论剑等大型竞赛，业内非常认可。）</li><li>很遗憾，我最多的就是省三了hh，目前来看挺失败的。不过这倒也正常，本身就是一个比较笨的人，还去打竞赛hhh。俗话笨鸟先飞，而我这只笨鸟晚飞，还飞的慢。能捉到虫就不错了。</li></ul>]]></content>
    
    
    <summary type="html">大专竞赛之路</summary>
    
    
    
    <category term="学习" scheme="https://www.impdx.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="自传" scheme="https://www.impdx.vip/tags/%E8%87%AA%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>记一次靶场渗透-从0到webshell</title>
    <link href="https://www.impdx.vip/posts/d62cbf20/"/>
    <id>https://www.impdx.vip/posts/d62cbf20/</id>
    <published>2022-01-25T13:45:46.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<h1>1.信息收集</h1><ul><li><p>80</p><ul><li>docker环境 大马看目录有.dockerenv</li></ul></li><li><p>888 phpmyadmin</p></li><li><p>8888  宝塔后台，尝试访问因无777权限</p></li><li><p>22</p><ul><li>open-ssh据钟馗之眼/quake/namp得知</li></ul></li><li><p>21</p><ul><li>ftpd据钟馗之眼/quake/namp得知</li></ul></li><li><p>8080</p><ul><li>vulhub docker</li></ul></li><li><p>8090</p><ul><li><p>vulhub docker</p><h1>2.尝试切入点</h1><p><strong>由于各大搜索引擎没有过多的收录，所以被迫采取主动扫描</strong></p></li></ul></li><li><p>Web，80端口直接上扫描器</p></li></ul><p><img src="https://image.impdx.vip/2022-01-25_21-31.png" alt=""></p><ul><li><p>下载www.zip看看源码（应该是某个师傅打包的？那地方还有webshell）,然后都访问一遍康康</p></li><li><p>先去admin看看，发现有管理员登录和普通登录（弱密码没有尝试）</p></li><li><p>注册新用户，看到可以更改头像，想到文件上传，尝试上一句话木马。</p></li></ul><p>看到有后缀检测，经多次尝试确认是Content-Type 检测<br>于是bp抓包绕过</p><p><img src="https://image.impdx.vip/2022-01-25_21-33.png" alt=""></p><p>尝试了很多次依然不行，突然想起有源码</p><ul><li>接着会发现F12里面的地址无法访问，于是去查看之前源码，<img src="https://image.impdx.vip/2022-01-25_21-36_1.png" alt=""></li></ul><p>虽然没学过php，但根据大概语法以及注释得知大图后面加上了big，而小图（F12看到的）没有big</p><p>于是乎访问路径+big.php 发现上马成功</p><p>蚁剑进行链接<img src="https://image.impdx.vip/2022-01-25_21-34.png" alt=""></p><p>直接传大马</p><p><img src="https://image.impdx.vip/2022-01-25_21-34.png" alt=""></p><p>打开大马<img src="https://image.impdx.vip/2022-01-25_21-30.png" alt=""></p><p>接着从源码和目录文件中翻阅</p><p>得知数据库配置文件（不知这一个文件）</p><p><img src="https://image.impdx.vip/2022-01-25_21-36.png" alt=""></p><p>连数据库</p><p>注意：有俩个数据库</p><p><img src="https://image.impdx.vip/2022-01-25_21-35.png" alt=""></p><p>至此web后期不会了，提权没太多了解由于是linux，大马自带的提权也无法使用，至于反弹msf和shell，无公网ip的机器可操作，文件只有www:www组的权限也就是655.</p><p>（通过日志可以看到其他师傅的方法）</p><h1>3.尝试FTP/SSH</h1><ul><li>FTP没有开启匿名登录，看到有CVE但不会利用</li><li>SSH版本较低有CVE，但不太会用</li></ul><h1>4.没有尝试的攻击</h1><ul><li>无授权：钓鱼，社工</li><li>因为太菜：docker逃逸，msf联动，反弹提权，内网扫描跳板等</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1.信息收集&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;80&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker环境 大马看目录有.dockerenv&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;888 phpmyadmin&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;8888  宝塔后台，</summary>
      
    
    
    
    <category term="笔记" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="靶场" scheme="https://www.impdx.vip/tags/%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux 基本知识点</title>
    <link href="https://www.impdx.vip/posts/77a8/"/>
    <id>https://www.impdx.vip/posts/77a8/</id>
    <published>2021-12-05T15:11:51.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux 基本知识点</h1><p><em><strong>请注意，大部分知识点都可以在archwiki中找到</strong></em></p><hr><p><em><strong>archwiki是linux最好用，最全的wiki之一，请学会使用/阅读</strong></em></p><h2 id="不知如何分类">不知如何分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo 提升到root运行权限</span><br><span class="line">ifconfig 查看ip 没有包无法运行 最小化安装可能不带</span><br><span class="line">ip add 查看ip 一般linux都自带</span><br><span class="line">****</span><br><span class="line">查看命令的参数，重要</span><br><span class="line">man</span><br><span class="line">help</span><br><span class="line">****</span><br><span class="line"></span><br><span class="line">ctrl+c  中断</span><br><span class="line">ctrl+z挂起，如进入python ctrl+c 没用作用</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="系统开关机">系统开关机</h2><h3 id="关机">关机</h3><ul><li><code>shutdown -h now </code>立刻关机（常用）</li><li><code>halt </code></li><li><code>poweroff</code></li><li><code>shutdown -h 10</code>  10分钟后自动关机</li></ul><h3 id="重启">重启</h3><blockquote><p>一般我就用着俩</p></blockquote><ul><li><code>reboot</code></li><li><code>shutdown -r -h</code></li></ul><h2 id="改源">改源</h2><blockquote><p>镜像源：tuna（清华），中科大，163，阿里，搜狐，腾讯，华为</p></blockquote><p><em><strong>sync表示源在同步中</strong></em></p><ul><li>debian系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>centos系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">         -e &#x27;s|^#baseurl=http://mirror.centos.org/$contentdir|baseurl=https://mirrors.ustc.edu.cn/centos|g&#x27; \</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/CentOS-Linux-AppStream.repo \</span><br><span class="line">         /etc/yum.repos.d/CentOS-Linux-BaseOS.repo \</span><br><span class="line">         /etc/yum.repos.d/CentOS-Linux-Extras.repo \</span><br><span class="line">         /etc/yum.repos.d/CentOS-Linux-PowerTools.repo \</span><br><span class="line">         /etc/yum.repos.d/CentOS-Linux-Plus.repo</span><br></pre></td></tr></table></figure><ul><li>arch 系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><h2 id="源更新，安装软件">源更新，安装软件</h2><ul><li>debian</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt update //更新源</span><br><span class="line">sudo apt upgrade //升级软件包</span><br><span class="line">apt list --upgradeable //列出可更新的软件包</span><br><span class="line">apt install xxx //安装软件包</span><br><span class="line">sudo apt autoremove xxx//删除软件包</span><br><span class="line">sudo apt show xxx //显示包的版本依赖等</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>arch</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syyu //更新</span><br><span class="line">pacman -S xxx //安装</span><br><span class="line">paru //用法一样，AUR</span><br></pre></td></tr></table></figure><h2 id="文件与目录管理">文件与目录管理</h2><ul><li><p><code>ls</code>  列出目录及文件名</p></li><li><p><code>cd</code> 切换目录</p></li><li><p><code>pwd</code> 显示目前的目录</p></li><li><p><code>mkdir</code> 创建一个新的目录</p></li><li><p><code>rmdir</code>删除一个空的目录</p></li><li><p><code>cp</code> 复制文件或目录</p></li><li><p><code>touch</code> 创建一个文件</p></li><li><p><code>rm</code> 删除文件或目录 千万别<code>sudo rm -rf /*</code></p></li><li><p><code>mv</code> 移动文件与目录</p></li><li><p><code>cat</code> 查看文件</p></li><li><p><code>unzip</code>  解压zip文件等具体看man/help -v查看解压，后面直接跟压缩包直接解压</p></li></ul><h2 id="VIM-nano">VIM &amp;&amp; nano</h2><ul><li><p>Vim 是一个功能非常强大，且具有很强扩展性的编辑器。你只要知道他很<code>牛</code>就对了</p></li><li><p>中文文档https://yianwillis.github.io/vimcdoc/doc/help.html</p></li><li><p>退出 <code>:q</code></p></li><li><p>保存 <code>：w</code></p></li><li><p>保存退出<code>：wq</code></p></li><li><p>强制执行<code>：！</code></p></li><li><p>强制保存退出<code>：wq!</code></p></li><li><p>插入文本</p><ul><li><code>i</code>当前位置插入</li><li><code>o</code>下一行位置插入</li><li><code>O</code>上一行位置插入</li><li><code>I</code> 光标所在行的最前面插入</li><li><code>a</code>光标后插入</li><li><code>A</code>行尾插入</li></ul></li><li><p><code>u</code>撤销</p></li><li><p><code>ctrl+r</code> 撤销上一次撤销的行动</p></li><li><p>复制粘贴 y和p,有y10j这种用法，很棒</p></li></ul><blockquote><p>有兴趣可以看看https://www.runoob.com/linux/linux-vim.html</p></blockquote><hr><ul><li>nano更偏向于初学者</li><li>^代表ctrl</li><li>M代表alt</li><li>看help和下面那些基本操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+G，显示帮助文本</span><br><span class="line"></span><br><span class="line">Ctrl+O，保存当前文件</span><br><span class="line"></span><br><span class="line">Ctrl+R，读取其他文件并插入光标位置</span><br><span class="line"></span><br><span class="line">Ctrl+Y，跳至上一屏幕</span><br><span class="line"></span><br><span class="line">Ctrl+K，剪切当前一行</span><br><span class="line"></span><br><span class="line">Ctrl+C，显示光标位置</span><br><span class="line"></span><br><span class="line">Ctrl+X，退出编辑文本</span><br><span class="line"></span><br><span class="line">Ctrl+J，对其当前段落（以空格为分隔符）</span><br><span class="line"></span><br><span class="line">Ctrl+W，搜索文本位置</span><br><span class="line"></span><br><span class="line">Ctrl+V，跳至下一屏幕</span><br><span class="line"></span><br><span class="line">Ctrl+U，粘贴文本至光标处</span><br><span class="line"></span><br><span class="line">Ctrl+T，运行拼写检查</span><br><span class="line"></span><br><span class="line">Ctrl+_，跳转到某一行</span><br><span class="line"></span><br><span class="line">ALT+U，撤销</span><br><span class="line"></span><br><span class="line">ALT+E，重做</span><br><span class="line"></span><br><span class="line">ALT+Y, 语法高亮</span><br><span class="line"></span><br><span class="line">ALT+#，显示行号</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>常用检测网络是否通顺</h1><ul><li><p><code>ping</code> 默认ICMP</p></li><li><p><code>TCPping</code> 走tcp ping</p></li><li><p><code>curl</code> 获取web服务器文件，直接在终端显示，比如curl <code>www.baidu.com</code></p></li></ul><h1>linux 权限</h1><p>（稍微带一下）<br>有兴趣可以去Google</p><ul><li><code>chmod +x xxx </code>给予运行权限</li><li><code>chmod 777 xxx </code>一般不这么写，给予任何人的所有权限，读写执行</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/file-llls22.jpg" alt="如何看权限"><br><img src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg" alt="权限解读1"></p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/rwx-standard-unix-permission-bits.png" alt="chmod_ugo"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u user 文件所有者</span><br><span class="line">g group 文件所有者所在组</span><br><span class="line">o others 所有其他用户</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">左对齐</th><th style="text-align:center">右对齐</th><th style="text-align:center">居中对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">读 + 写 + 执行</td><td style="text-align:center">rwx</td><td style="text-align:center">111</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">读 + 写</td><td style="text-align:center">rw-</td><td style="text-align:center">110</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">读 + 执行</td><td style="text-align:center">r-x</td><td style="text-align:center">101</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">只读</td><td style="text-align:center">r–</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">写 + 执行</td><td style="text-align:center">-wx</td><td style="text-align:center">011</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">只写</td><td style="text-align:center">-w-</td><td style="text-align:center">010</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">只执行</td><td style="text-align:center">–x</td><td style="text-align:center">001</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">无</td><td style="text-align:center">—</td><td style="text-align:center">000</td></tr></tbody></table><ul><li><code>umask</code> 可以了解一下</li></ul><h2 id="Git基本使用">Git基本使用</h2><ul><li><code>git init</code> git 初始化</li><li><code>git clone</code> //克隆项目到本地</li><li><code>git add .</code> //添加所有项目到目前分支</li><li><code>git commit -m &quot;更新说明&quot;</code> //把内容说明添加到本地仓库</li><li><code>git push</code> //将本地仓库提交上去</li><li><code>git pull</code> //将远程仓库同步到本地仓库</li><li><code>git diff </code> //比较暂存区和本地文件区别</li><li><code>git config </code> // git配置，具体看参数</li><li><code>git log</code> // 查看历史提交记录</li><li><code>git status </code> // 查看当前状态</li><li><code>git branch xxx</code> // 创建分支</li><li>…具体请参考github/git文档 （可以适当了解SVN，gitlab，版本控制，分支等）</li></ul><h1>linux 跑python</h1><ul><li><p><code>python</code> 默认使用python2</p></li><li><p><code>python3</code>默认使用python3</p></li><li><p><code>pip3</code> //建议使用镜像源，tuna有源，可用-i参数，也可以修改全局</p></li></ul><h1>（非必须）如使用linux为主系统可看</h1><h2 id="debian（kali）-安装中文输入法">debian（kali） 安装中文输入法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt fcitx5</span><br><span class="line">sudo apt install fcitx-googlepinyin</span><br><span class="line">apt update -y &amp;&amp; apt install xfonts-intl-chinese ttf-wqy-microhei ttf-wqy-zenhei</span><br><span class="line">sudo dpkg-reconfigure locales</span><br><span class="line"># 进入图形界面，选中en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8（空格是选择，tab是切换，*是选中）</span><br><span class="line">//选择语言，建议首选en_us.utf8,就是英文，其次中文，因为英文对某些软件支持较好。</span><br><span class="line">apt clean &amp;&amp; apt update -y</span><br><span class="line"></span><br><span class="line">ctrl+space切换输入法 //可以通过设置更改</span><br></pre></td></tr></table></figure><h2 id="gcc">gcc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o 1.c 1</span><br><span class="line"></span><br><span class="line">./1</span><br><span class="line">//g++ 类似，可参考参数开启O2优化</span><br></pre></td></tr></table></figure><h2 id="gdb（暂时无）">gdb（暂时无）</h2><h2 id="Linux-更换-编译内核">Linux 更换/编译内核</h2><p>编译内核请参考另一篇文章：<a href="https://www.impdx.vip/posts/1017/">https://www.impdx.vip/posts/1017/</a> 都是基于debian，差别不是很大</p><h2 id="安装QQ等国内软件可参考archwiki">安装QQ等国内软件可参考archwiki</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://wiki.archlinux.org/title/Tencent_QQ_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</span><br><span class="line">如果没找到合适的就去github搜索，很多基于webqq开发的包。</span><br></pre></td></tr></table></figure><h2 id="linux桌面">linux桌面</h2><ul><li><p>gnome</p></li><li><p>kde</p></li><li><p>xfce</p></li><li><p>lxqt</p></li><li><p>…等</p></li><li><p>机器配置高首选kde，花里胡哨美化效果好</p></li><li><p>其次gnome上手即可用，</p></li><li><p>机器配置差建议xfce，lxqt等</p></li></ul><hr><p>后期看情况更新本文</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Linux 基本知识点&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;请注意，大部分知识点都可以在archwiki中找到&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;archwiki是linux最好用，最全的wiki之一，请学会使用/阅读&lt;/st</summary>
      
    
    
    
    <category term="笔记" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="linux" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/linux/"/>
    
    
    <category term="linux" scheme="https://www.impdx.vip/tags/linux/"/>
    
    <category term="arch linux" scheme="https://www.impdx.vip/tags/arch-linux/"/>
    
  </entry>
  
  <entry>
    <title>arch-坚果云/白屏/闪退</title>
    <link href="https://www.impdx.vip/posts/2074/"/>
    <id>https://www.impdx.vip/posts/2074/</id>
    <published>2021-11-15T06:15:51.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<h1>环境描述</h1><ul><li><p>刚装好arch因为keepass选择了webdav，所以需要坚果云同步。</p></li><li><p>报错为 <code>Nutstore meets some problems. You may try to restart it to fix. If it still</code></p></li><li><p>之后同步直接闪退，由于log加密所以发邮件给官方，官方回复，配置中文编码和字体</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-----------</span><br><span class="line">OS: Arch Linux x86_64</span><br><span class="line">Kernel: 5.14.16-arch1-1</span><br><span class="line">Uptime: 1 hour, 44 mins</span><br><span class="line">Packages: 951 (pacman)</span><br><span class="line">Shell: zsh 5.8</span><br><span class="line">Resolution: 1920x1080</span><br><span class="line">DE: Plasma 5.23.3</span><br><span class="line">WM: KWin</span><br><span class="line">WM Theme: Breeze 微风</span><br><span class="line">Theme: Breeze Light [Plasma], Breeze [GTK2/3]</span><br><span class="line">Icons: [Plasma], breeze-dark [GTK2/3]</span><br><span class="line">Terminal: konsole</span><br><span class="line">CPU: AMD Ryzen 9 3950X (32) @ 3.500GHz</span><br><span class="line">GPU: NVIDIA GeForce GTX 1060 6GB</span><br><span class="line">Memory: 6057MiB / 64220MiB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>解决方案</h1><h3 id="配置中文编码，安装中文环境">配置中文编码，安装中文环境</h3><ul><li>编辑locale.gen文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen   </span><br></pre></td></tr></table></figure><ul><li>1.将以下行去掉注释</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zh_CN.GB18030 GB18030</span><br><span class="line">zh_CN.GBK GBK</span><br><span class="line">zh_CN.UTF-<span class="number">8</span> UTF-<span class="number">8</span></span><br><span class="line">zh_CN.GB2312</span><br><span class="line">zh_TW BIG5</span><br></pre></td></tr></table></figure><ul><li><p>2.重新编译<code>locale-gen </code></p></li><li><p>3.安装中文字体<code>pacman -S wqy-zenhei  </code>(参考archwiki <a href="https://wiki.archlinux.org/title/Fonts_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/title/Fonts_(简体中文)</a>)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;环境描述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;刚装好arch因为keepass选择了webdav，所以需要坚果云同步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;报错为 &lt;code&gt;Nutstore meets some problems. You may try to res</summary>
      
    
    
    
    <category term="笔记" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="linux" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/linux/"/>
    
    
    <category term="linux" scheme="https://www.impdx.vip/tags/linux/"/>
    
    <category term="arch linux" scheme="https://www.impdx.vip/tags/arch-linux/"/>
    
  </entry>
  
  <entry>
    <title>MD5 加密原理&amp;&amp;实际应用</title>
    <link href="https://www.impdx.vip/posts/e3f9/"/>
    <id>https://www.impdx.vip/posts/e3f9/</id>
    <published>2021-10-13T11:25:43.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<h1>MD5 加密原理&amp;&amp;实际应用</h1><h2 id="原理">原理</h2><ul><li>MD5特点<ul><li>唯一性，是有损加密，不可逆向，现有破解都是用<strong>撞库</strong>实现</li><li>不管多长的字符串,加密后<strong>长度都是一样长</strong></li><li>唯一性：一个文件,不管多大,小到几k,大到几G,你<strong>只要改变</strong>里面<strong>某个</strong>字符,那么都会<strong>导致MD5值改变.</strong><br><strong>作用:<strong>很多软件和应用在网站提供下载资源,其中</strong>包含了对文件的MD5码</strong>,用户下载后只需要用<strong>工具测一下下载好的文件</strong>,通过对比就知道<strong>该文件是否有过更改变动</strong>.</li><li>不可逆性</li></ul></li><li>MD5消息摘要算法，属Hash算法一类。MD5算法对输入任意长度的<strong>消息</strong>进行运行，产生一个128位的消息摘要。</li><li>MD5的用处不是用来加密信息解密信息的，个人观点：用来做一个全局唯一标记，比如impdx或者图片文件产生的md5永远只会是一个值，我们不用去对比文件或者文本是否相同，只需要判断md5是否相同就可以判断了。</li></ul><p><strong>算法原理</strong></p><p><strong>1、数据填充</strong></p><p>对消息进行数据填充，使消息的长度对512取模得448，设消息长度为X，即满足X mod 512=448。根据此公式得出需要填充的数据长度。</p><p>填充方法：在消息后面进行填充，填充第一位为1，其余为0。</p><p><strong>2、添加消息长度</strong></p><p>在第一步结果之后再填充上原消息的长度，可用来进行的存储长度为64位。如果消息长度大于264，则只使用其低64位的值，即（消息长度 对 264取模）。</p><p>在此步骤进行完毕后，最终消息长度就是512的整数倍。</p><p><strong>3、数据处理</strong></p><p>准备需要用到的数据：</p><ul><li>4个常数： A = 0x67452301, B = 0x0EFCDAB89, C = 0x98BADCFE, D = 0x10325476;</li><li>4个函数：F(X,Y,Z)=(X &amp; Y) | ((~X) &amp; Z); G(X,Y,Z)=(X &amp; Z) | (Y &amp; (~Z)); H(X,Y,Z)=X ^ Y ^ Z; I(X,Y,Z)=Y ^ (X | (~Z));</li></ul><p>把消息分以512位为一分组进行处理，每一个分组进行4轮变换，以上面所说4个常数为起始变量进行计算，</p><p>重新输出4个变量，以这4个变量再进行下一分组的运算，如果已经是最后一个分组，则这4个变量为最后的结果，即MD5值。</p><figure class="highlight plaintext"><figcaption><span>^ | ~</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">运算（6 &amp; 2）</span><br><span class="line"></span><br><span class="line">6的二进制：0110</span><br><span class="line"></span><br><span class="line">2的二进制：0010</span><br><span class="line">6      000···000 0110（一共32位）</span><br><span class="line"></span><br><span class="line">&amp;（相同位置都为1，才能去1，否则为0）</span><br><span class="line">2      000···000 0010（一共32位）</span><br><span class="line">结果 000···000 0010</span><br><span class="line"></span><br><span class="line">结果首位（32位的第一位）为0，是正数二进制，不需要转换，这结果为2。</span><br><span class="line">与：1 &amp; 1 = 1, 1 &amp; 0 = 0, 0 &amp; 1 = 0, 0 &amp; 0 = 0;// 不同时为0，都是1时得1，都是2时得2</span><br><span class="line">或：1 | 1 = 1, 1 | 0 = 1, 0 | 1 = 1, 0 | 0 = 0;//有1得1，都是0得0；</span><br><span class="line">非：~0 = 1, ~1 = 0;//取反</span><br><span class="line">异或运算（^）：0^0=0； 0^1=1；1^0=1；1^1=0; //不同时为1</span><br></pre></td></tr></table></figure><p>具体计算的实现较为复杂，建议查阅相关书籍。<br><img src="https://image.impdx.vip/imagesMD5%E5%8E%9F%E7%90%86.png" alt="1"></p><p><img src="https://image.impdx.vip/imagesMD5%E5%8E%9F%E7%90%86%E5%BE%AA%E7%8E%AF%E5%8A%A0%E5%AF%86.png" alt="2"></p><ul><li>我们可以这么理解<br>X：字符串长度<br>要求<br>X mod 512=448<br>如果不行则加长度，进行填充，填充第一位为1，其余为0。<br>接着  长度如果超过2的64次方 位，只取低64位，即对 2的64取模</li></ul><p>接着分组进行循环运算，最后换位就变成了加密MD5</p><h2 id="MD5的用处">MD5的用处</h2><ul><li><p>用来检验文件是否被修改，通常和sha1或者sha256配合检查，比如txt文件中修改了一个字母，那么他的md5会完全不相同。</p></li><li><p>对于某些明文密码传输，需要保护，普通加密方式具有可逆性，但是MD5不可逆。但常常不会单独使用MD5进行，因为通常的密码都可以通过撞库来获取（撞库：通过用空间换时间的方式，由于MD5的唯一性，我可以用计算机跑出任何字符串的MD5，比如12345的MD5，可以跑出来，也可以通过别人分享来获取）</p></li></ul><h2 id="实战利用PHP弱类型来比较MD5">实战利用PHP弱类型来比较MD5</h2><ul><li><p>例子只演示MD5在PHP中的漏洞</p></li><li><p>什么是弱类型,众所周知PHP是一门弱语言，不必向 PHP 声明该变量的数据类型，PHP 会根据变量的值，自动把变量的值转换为正确的数据类型，但在这个转换过程中就有可能引发一些安全问题。</p></li><li><p>当一个字符串被当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.',‘e’,'E’并且其数值值在整形的范围之内，该字符串被当作int来取值。其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。</p></li></ul><p><strong>题目来自于bugku</strong></p><p><a href="https://ctf.bugku.com/challenges/detail/id/94.html">https://ctf.bugku.com/challenges/detail/id/94.html</a></p><p>一进去我们可以看到题目是用MD5，同时用?a=a显示false。</p><ul><li>知识点<ul><li>PHP在处理哈希字符串时，会利用&quot;!=“或”==&quot;来对哈希值进行比较，它把每一个以&quot;0E&quot;开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以&quot;0E&quot;开头的，那么PHP将会认为他们相同，都是0。</li><li>比如s1885207154a这串字符串通过MD5加密后为0e509367213418206700842008763514</li></ul></li></ul><p>攻击者可以利用这一漏洞，通过输入一个经过哈希后以&quot;0E&quot;开头的字符串，即会被PHP解释为0，如果数据库中存在这种哈希值以&quot;0E&quot;开头的密码的话，他就可以以这个用户的身份登录进去，尽管并没有真正的密码。</p><p>输入 a=s1885207154a</p><p>成功绕过</p><p><strong>最后附上c++版本的MD5实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MD5.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*4组计算函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> X, <span class="keyword">unsigned</span> <span class="keyword">int</span> Y, <span class="keyword">unsigned</span> <span class="keyword">int</span> Z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X &amp; Y) | ((~X) &amp; Z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> X, <span class="keyword">unsigned</span> <span class="keyword">int</span> Y, <span class="keyword">unsigned</span> <span class="keyword">int</span> Z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X &amp; Z) | (Y &amp; (~Z));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">H</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> X, <span class="keyword">unsigned</span> <span class="keyword">int</span> Y, <span class="keyword">unsigned</span> <span class="keyword">int</span> Z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> X ^ Y ^ Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">I</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> X, <span class="keyword">unsigned</span> <span class="keyword">int</span> Y, <span class="keyword">unsigned</span> <span class="keyword">int</span> Z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Y ^ (X | (~Z));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*4组计算函数结束*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*32位数循环左移实现函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ROL</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;s, <span class="keyword">unsigned</span> <span class="keyword">short</span> cx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cx &gt; <span class="number">32</span>)cx %= <span class="number">32</span>;</span><br><span class="line">    s = (s &lt;&lt; cx) | (s &gt;&gt; (<span class="number">32</span> - cx));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*B\L互转，接收UINT类型*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ltob</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp = i;<span class="comment">//保存副本</span></span><br><span class="line">    byte *psour = (byte*)&amp;tmp, *pdes = (byte*)&amp;i;</span><br><span class="line">    pdes += <span class="number">3</span>;<span class="comment">//调整指针，准备左右调转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CopyMemory</span>(pdes - i, psour + i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MD5循环计算函数，label=第几轮循环（1&lt;=label&lt;=4），lGroup数组=4个种子副本，M=数据（16组32位数指针）</span></span><br><span class="line"><span class="comment">种子数组排列方式: --A--D--C--B--，即 lGroup[0]=A; lGroup[1]=D; lGroup[2]=C; lGroup[3]=B;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AccLoop</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> label, <span class="keyword">unsigned</span> <span class="keyword">int</span> *lGroup, <span class="keyword">void</span> *M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *i1, *i2, *i3, *i4, TAcc, tmpi = <span class="number">0</span>; <span class="comment">//定义:4个指针； T表累加器； 局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(*clac)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> X, <span class="keyword">unsigned</span> <span class="keyword">int</span> Y, <span class="keyword">unsigned</span> <span class="keyword">int</span> Z)</span></span>; <span class="comment">//定义函数类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> rolarray[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123; <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span> &#125;,</span><br><span class="line">        &#123; <span class="number">5</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span> &#125;,</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span> &#125;,</span><br><span class="line">        &#123; <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span> &#125;</span><br><span class="line">    &#125;;<span class="comment">//循环左移-位数表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> mN[<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;,</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span> &#125;,</span><br><span class="line">        &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">9</span> &#125;</span><br><span class="line">    &#125;;<span class="comment">//数据坐标表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *pM = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>*&gt;(M);<span class="comment">//转换类型为32位的Uint</span></span><br><span class="line">    TAcc = ((label - <span class="number">1</span>) * <span class="number">16</span>) + <span class="number">1</span>; <span class="comment">//根据第几轮循环初始化T表累加器</span></span><br><span class="line">    clac clacArr[<span class="number">4</span>] = &#123; F, G, H, I &#125;; <span class="comment">//定义并初始化计算函数指针数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*一轮循环开始（16组-&gt;16次）*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*进行指针自变换*/</span></span><br><span class="line">        i1 = lGroup + ((<span class="number">0</span> + i) % <span class="number">4</span>);</span><br><span class="line">        i2 = lGroup + ((<span class="number">3</span> + i) % <span class="number">4</span>);</span><br><span class="line">        i3 = lGroup + ((<span class="number">2</span> + i) % <span class="number">4</span>);</span><br><span class="line">        i4 = lGroup + ((<span class="number">1</span> + i) % <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*第一步计算开始: A+F(B,C,D)+M[i]+T[i+1] 注:第一步中直接计算T表*/</span></span><br><span class="line">        tmpi = (*i1 + clacArr[label - <span class="number">1</span>](*i2, *i3, *i4) + pM[(mN[label - <span class="number">1</span>][i])] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">0x100000000</span>UL * <span class="built_in">abs</span>(<span class="built_in">sin</span>((<span class="keyword">double</span>)(TAcc + i)))));</span><br><span class="line">        <span class="built_in">ROL</span>(tmpi, rolarray[label - <span class="number">1</span>][i % <span class="number">4</span>]);<span class="comment">//第二步:循环左移</span></span><br><span class="line">        *i1 = *i2 + tmpi;<span class="comment">//第三步:相加并赋值到种子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*接口函数，并执行数据填充*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span>* <span class="title">MD5</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* mStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mLen = <span class="built_in">strlen</span>(mStr); <span class="comment">//计算字符串长度</span></span><br><span class="line">    <span class="keyword">if</span> (mLen &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> FillSize = <span class="number">448</span> - ((mLen * <span class="number">8</span>) % <span class="number">512</span>); <span class="comment">//计算需填充的bit数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> FSbyte = FillSize / <span class="number">8</span>; <span class="comment">//以字节表示的填充数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> BuffLen = mLen + <span class="number">8</span> + FSbyte; <span class="comment">//缓冲区长度或者说填充后的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *md5Buff = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[BuffLen]; <span class="comment">//分配缓冲区</span></span><br><span class="line">    <span class="built_in">CopyMemory</span>(md5Buff, mStr, mLen); <span class="comment">//复制字符串到缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*数据填充开始*/</span></span><br><span class="line">    md5Buff[mLen] = <span class="number">0x80</span>; <span class="comment">//第一个bit填充1</span></span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;md5Buff[mLen + <span class="number">1</span>], FSbyte - <span class="number">1</span>); <span class="comment">//其它bit填充0，另一可用函数为FillMemory</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lenBit = mLen * <span class="number">8ULL</span>; <span class="comment">//计算字符串长度，准备填充</span></span><br><span class="line">    <span class="built_in">CopyMemory</span>(&amp;md5Buff[mLen + FSbyte], &amp;lenBit, <span class="number">8</span>); <span class="comment">//填充长度</span></span><br><span class="line">    <span class="comment">/*数据填充结束*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*运算开始*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> LoopNumber = BuffLen / <span class="number">64</span>; <span class="comment">//以16个字为一分组，计算分组数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> A = <span class="number">0x67452301</span>, B = <span class="number">0x0EFCDAB89</span>, C = <span class="number">0x98BADCFE</span>, D = <span class="number">0x10325476</span>;<span class="comment">//初始4个种子，小端类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *lGroup = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>[<span class="number">4</span>]&#123; A, D, C, B&#125;; <span class="comment">//种子副本数组,并作为返回值返回</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> Bcount = <span class="number">0</span>; Bcount &lt; LoopNumber; ++Bcount) <span class="comment">//分组大循环开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*进入4次计算的小循环*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">short</span> Lcount = <span class="number">0</span>; Lcount &lt; <span class="number">4</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AccLoop</span>(++Lcount, lGroup, &amp;md5Buff[Bcount * <span class="number">64</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*数据相加作为下一轮的种子或者最终输出*/</span></span><br><span class="line">        A = (lGroup[<span class="number">0</span>] += A);</span><br><span class="line">        B = (lGroup[<span class="number">3</span>] += B);</span><br><span class="line">        C = (lGroup[<span class="number">2</span>] += C);</span><br><span class="line">        D = (lGroup[<span class="number">1</span>] += D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*转换内存中的布局后才能正常显示*/</span></span><br><span class="line">    <span class="built_in">ltob</span>(lGroup[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">ltob</span>(lGroup[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">ltob</span>(lGroup[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">ltob</span>(lGroup[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">delete</span>[] md5Buff; <span class="comment">//清除内存并返回</span></span><br><span class="line">    <span class="keyword">return</span> lGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;MD5 加密原理&amp;amp;&amp;amp;实际应用&lt;/h1&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MD5特点
&lt;ul&gt;
&lt;li&gt;唯一性，是有损加密，不可逆向，现有破解都是用&lt;strong&gt;撞库&lt;/strong&gt;实现&lt;/li&gt;
&lt;li&gt;不管多长的字符串,加密</summary>
      
    
    
    
    <category term="笔记" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="密码学" scheme="https://www.impdx.vip/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>rot密码</title>
    <link href="https://www.impdx.vip/posts/e3a1/"/>
    <id>https://www.impdx.vip/posts/e3a1/</id>
    <published>2021-10-13T11:25:43.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<h1>rot密码</h1><h3 id="rot密码其实可以看作是凯撒密码的一种变式">rot密码其实可以看作是凯撒密码的一种变式</h3><ul><li>本质都是位移密码</li></ul><h2 id="特征">特征</h2><ul><li>rot5：只有数字进行了加密</li><li>rot13：只有数字和字母进行了加密</li><li>rot18：在rot13的基础上，步长改变</li><li>rot47：对所有字符进行加密<ul><li>rot47比较好识别，因为他的字符串加密往往是有着特殊符号比如</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E9:D :D 7=28L2H`abcN</span><br><span class="line">%wx$ x$ u&#123;pvL2H`abcN</span><br></pre></td></tr></table></figure><p>上面中的%$等符号</p><h3 id="rot具体区别">rot具体区别</h3><ul><li>rot5：只将字符串中的数字进行加密，步数为5，同时在0-9十个数字进行循环，如1在rot5加密后为6，而6在rot5加密后为1</li></ul><hr><ul><li>rot13：只将字符串中的字母进行加密，步数为13，加密方式上最接近凯撒密码，分别在A-Z或a-z之间循环，如A在rot13加密后为N,Z在rot13加密后为M</li></ul><hr><ul><li>rot18:字面意思(5+13=18) 即将上述两种加密方式结合，分别对数字和字母进行相应的操作</li></ul><hr><ul><li>rot47:由于无论是rot5、rot13或rot18都只能对数字和字母进行相应的加密，而对“！@#￥%&amp;”之类的符号却缺少加密，因此在此基础上引入ASCII码（对应图表见下）<ul><li>ASCII值进行位置替换，如当前为小写字母z-&gt;K，0-&gt;_。</li></ul></li></ul><h3 id="注意：用于ROT47编码的字符其ASCII值范围是33－126（原因是由于0-32以及127与字符表示无关！！）"><em><strong>注意：用于ROT47编码的字符其ASCII值范围是33－126（原因是由于0-32以及127与字符表示无关！！）</strong></em></h3><p><img src="https://image.impdx.vip/imagesASCII.webp" alt="2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;rot密码&lt;/h1&gt;
&lt;h3 id=&quot;rot密码其实可以看作是凯撒密码的一种变式&quot;&gt;rot密码其实可以看作是凯撒密码的一种变式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;本质都是位移密码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;特征&quot;&gt;特征&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;rot5：只有数字</summary>
      
    
    
    
    <category term="笔记" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="密码" scheme="https://www.impdx.vip/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>centos7搭建DVWA靶场</title>
    <link href="https://www.impdx.vip/posts/4699/"/>
    <id>https://www.impdx.vip/posts/4699/</id>
    <published>2021-10-07T14:05:14.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<h1>centos7 搭建 DVWA 靶场</h1><ul><li><p>github:<a href="https://github.com/digininja/DVWA">https://github.com/digininja/DVWA</a></p></li><li><p>centos7:<a href="https://mirror.tuna.tsinghua.edu.cn/centos/7.9.2009/isos/x86_64/">https://mirror.tuna.tsinghua.edu.cn/centos/7.9.2009/isos/x86_64/</a> (这里采用tuna[清华源])</p></li></ul><h1>配置centos基本环境</h1><h2 id="配置sudo">配置sudo</h2><ul><li>刚装好的centos默认用户不在sudo列表中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su //提升到root权限</span><br><span class="line">vim /etc/sudoers //编辑sudoers，vim不习惯，可以用其他编辑</span><br><span class="line">/root ALL=(ALL) ALL //不是vim跳过，`/`表示搜索  在这行的下面</span><br><span class="line">impdx ALL=(ALL) ALL //`impdx`是当前的用户名</span><br><span class="line">wq! //不是vim跳过，强制保存</span><br><span class="line">exit //退出root用户</span><br></pre></td></tr></table></figure><h2 id="配置源">配置源</h2><ul><li>此处采用清华源 [可用中科大/网易/阿里/搜狐等]</li><li>具体参考：<a href="https://mirror.tuna.tsinghua.edu.cn/help/centos/">https://mirror.tuna.tsinghua.edu.cn/help/centos/</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">         -e &#x27;s|^#baseurl=http://mirror.centos.org|baseurl=https://mirrors.tuna.tsinghua.edu.cn|g&#x27; \</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/CentOS-*.repo</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure><h1>配置DVWA</h1><ul><li>安装相关依赖</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mariadb*</span><br><span class="line">sudo yum install php php-mysqli php-gd</span><br><span class="line">sudo yum install httpd</span><br><span class="line">sudo yum install git unzip</span><br></pre></td></tr></table></figure><ul><li>设置自启动</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mariadb</span><br><span class="line">systemctl enable mariadb</span><br><span class="line">systemctl start httpd</span><br><span class="line">systemctl enable httpd</span><br></pre></td></tr></table></figure><h1>移动DVWA到www</h1><ul><li>下载可以用git clone /GUI界面直接浏览器下载/VMtools也可以</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将下载好的DVWA-master.zip解压  </span><br><span class="line">unzip DVWA-master.zip //解压  </span><br><span class="line">mv DVWA-master.zip DVWA //修改一下名字  </span><br><span class="line">mv DVWA /var/www/html //把文件夹移到apache下  </span><br><span class="line">chown apache:apache -R /var/www/html //拇指</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在html文件夹中</span><br><span class="line">cd DVWA/ 进入文件夹  </span><br><span class="line">其中README.md是官方的帮助文档，里面有很官方的搭建过程  </span><br><span class="line">cd config/ 进入config/下修改一下配置文件  </span><br><span class="line">使用cp命令保存原来文件，并复制一个文件改名为config.inc.php  </span><br><span class="line">cp config.inc.php.dist config.inc.php</span><br></pre></td></tr></table></figure><h2 id="设置数据库">设置数据库</h2><h3 id="初始化数据库">初始化数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> mysql -u root -p //进入数据库，初始化是回车进入，如果进入不了就先启动一下mariadb服务</span><br><span class="line">Enter password:</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; create database dvwa;</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; grant all on dvwa.* todvwa@localhost identified by &#x27;123456&#x27;;  </span><br><span class="line">MariaDB [(none)]&gt; flush privileges;  </span><br><span class="line">MariaDB [(none)]&gt; exit  </span><br></pre></td></tr></table></figure><p>此时重启一下mysql服务：systemctl restart mariadb</p><h3 id="修改一下DVWA的配置文件">修改一下DVWA的配置文件</h3><ul><li>可以自己去申请key，具体百度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#vim config.inc.php  </span><br><span class="line">$_DVWA[&#x27;db_server&#x27; ]?? = &#x27;localhost&#x27;;</span><br><span class="line"></span><br><span class="line">$_DVWA[&#x27;db_database&#x27; ] = &#x27;dvwa&#x27;;</span><br><span class="line"></span><br><span class="line">$_DVWA[ &#x27;db_user&#x27;]???? = &#x27;dvwa&#x27;;</span><br><span class="line"></span><br><span class="line">$_DVWA[&#x27;db_password&#x27; ] = &#x27;123456&#x27;;  //这里是在数据库里面设置的密码</span><br><span class="line"></span><br><span class="line">然后设置key：  </span><br><span class="line">$_DVWA[ &#x27;recaptcha_public_key&#x27; ]? =&#x27;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg&#x27;;</span><br><span class="line"></span><br><span class="line">$_DVWA[ &#x27;recaptcha_private_key&#x27; ] =&#x27;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ&#x27;;</span><br><span class="line"></span><br><span class="line">修改一下php.ini这个文件  </span><br><span class="line">vim /etc/php.ini  </span><br><span class="line">直接搜索 allow_url_include = Off //搜索到这个之后把Off 改为On</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">- 重启一下服务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>systemctl restart mariadb //重启数据库<br>systemctl restart httpd //重启apache<br>systemctl stop firewalld //关闭防火墙<br>setenforce 0 //关闭selinux</p><pre><code>最后去浏览器测试一下网址http://ip/DVWA/login.phpip是centos的ip用户名是admin,密码是password创建一下就可以了</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;centos7 搭建 DVWA 靶场&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;github:&lt;a href=&quot;https://github.com/digininja/DVWA&quot;&gt;https://github.com/digininja/DVWA&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="CTF,基础" scheme="https://www.impdx.vip/tags/CTF-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>AcWing 836. 并查集(数组)</title>
    <link href="https://www.impdx.vip/posts/811b/"/>
    <id>https://www.impdx.vip/posts/811b/</id>
    <published>2021-09-09T06:52:22.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目： <a href="https://www.acwing.com/problem/content/description/838/">https://www.acwing.com/problem/content/description/838/</a></li></ul><h2 id="先说一下本题思路">先说一下本题思路</h2><ul><li><p>1.看清题目，主要有俩个操作，合并和查询 。 总体思路是找到俩个祖宗节点，并且把俩个祖宗节点相连(其实就是改p[a的祖宗]=b的祖宗 比如p[3]=4，p[3]=p[4]=4,他们的祖宗都是4，)</p></li><li><p>2.合并是在一个数组中，利用下标和他所指向的值，如果他所指向的值一样，那么就是一个集合。用下表来记录具体数据。</p></li><li><p>3.查询直接查询祖宗节点，很好理解，就是比如说查询x，他就会查询p[x]的值，如果和x不一样，会查询find[p[x]]的值,这里有点绕，x如果和p[x]的值不一样，就查询find(p[x]),一个个找，找到祖宗节点，就是x和p[x]一样的节点，原始节点。</p></li><li><p>主要操作就是针对于祖宗节点进行的。</p></li><li><p>题目难点（个人愚见）：find函数，寻找祖宗节点的过程，下标和值的用法。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int p[N];</span><br><span class="line">int find(int x)   //找祖宗节点的函数</span><br><span class="line">&#123;</span><br><span class="line">  if(p[x] != x) p[x] = find(p[x]);</span><br><span class="line">  return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool only(int a,int b)  //判断是否在一个集合</span><br><span class="line">&#123;</span><br><span class="line">  return find(a)==find(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a,b;</span><br><span class="line">  char str,test;</span><br><span class="line">  int n,m;</span><br><span class="line"></span><br><span class="line">  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">  scanf(&quot;%c&quot;,&amp;test);  //消除回车</span><br><span class="line"></span><br><span class="line">  for(int i = 1;i&lt;=n; i++)</span><br><span class="line">    p[i]=i;</span><br><span class="line"></span><br><span class="line">  while(m--)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%c %d %d&quot;,&amp;str,&amp;a,&amp;b);</span><br><span class="line">    scanf(&quot;%c&quot;,&amp;test);  //消除回车</span><br><span class="line">    // printf(&quot;%c%d%d\n&quot;,str,a,b);</span><br><span class="line">    if(str == &#x27;M&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">      p[find(a)]=find(b); //合并操作，</span><br><span class="line">    &#125;</span><br><span class="line">    else if(str == &#x27;Q&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">      if(only(a,b)) printf(&quot;Yes\n&quot;);</span><br><span class="line">      else printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;题目： &lt;a href=&quot;https://www.acwing.com/problem/content/description/838/&quot;&gt;https://www.acwing.com/problem/content/description/838/&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="笔记" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法,ACM" scheme="https://www.impdx.vip/tags/%E7%AE%97%E6%B3%95-ACM/"/>
    
  </entry>
  
  <entry>
    <title>AcWing 787. 归并排序 &amp;&amp; 注释 &amp;&amp; 思路</title>
    <link href="https://www.impdx.vip/posts/1026/"/>
    <id>https://www.impdx.vip/posts/1026/</id>
    <published>2021-07-22T13:08:08.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="原题链接-2">原题链接</h2><p><a href="https://www.acwing.com/problem/content/description/789/">https://www.acwing.com/problem/content/description/789/</a></p><p><em><strong>2021/4/19 21:10</strong></em></p><h1>思路</h1><ul><li>先分开，分成俩个组</li><li>用双指针遍历，小的放入tmp数组</li><li>如果有剩余，把剩余放入tmp数组</li><li>把tmp的数据替换到q数组中</li></ul><h1>后续会更新</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1000010;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int q[N],tmp[N];</span><br><span class="line"></span><br><span class="line">void merge_sort(int *q,int l ,int r)</span><br><span class="line">&#123;</span><br><span class="line">  if(l &gt;= r) return ;</span><br><span class="line"></span><br><span class="line">  int mid = l + r &gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">  merge_sort(q, l, mid),merge_sort(q, mid+1, r);      // 分左边右边，俩组数据</span><br><span class="line"></span><br><span class="line">  int k = 0,i = l,j = mid + 1;        // k表示，tmp当前放入的第几个数</span><br><span class="line"></span><br><span class="line">  while(i &lt;= mid&amp;&amp;j &lt;= r)   // 俩组数据比较大小，双指针算法，小的放入tmp</span><br><span class="line">    if(q[i] &lt;= q[j]) tmp[k ++ ]=q[ i ++];</span><br><span class="line">    else tmp[k ++] = q[j ++];</span><br><span class="line"></span><br><span class="line">  while(i &lt;= mid) tmp[k ++] = q[i ++];      //把剩余的数据放进tmp，从tmp[k]开始放</span><br><span class="line">  while(j &lt;= r) tmp[k ++] = q[j ++];</span><br><span class="line"></span><br><span class="line">  for(int i=l,j=0;i&lt;=r;i++,j++) q[i]=tmp[j];  //把q的数据换成tmp的数据</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;q[i]);</span><br><span class="line"></span><br><span class="line">  merge_sort(q,0,n-1);</span><br><span class="line"></span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">    printf(&quot;%d &quot;,q[i]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;原题链接-2&quot;&gt;原题链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/description/789/&quot;&gt;https://www.acwing.com/problem/content/d</summary>
      
    
    
    
    
    <category term="算法,ACM" scheme="https://www.impdx.vip/tags/%E7%AE%97%E6%B3%95-ACM/"/>
    
  </entry>
  
  <entry>
    <title>AcWing 798. 前缀和&amp;&amp;前缀矩阵&amp;&amp;差分&amp;&amp;差分矩阵 代码&amp;注释&amp;&amp;原理</title>
    <link href="https://www.impdx.vip/posts/4639/"/>
    <id>https://www.impdx.vip/posts/4639/</id>
    <published>2021-07-22T13:04:14.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="原题链接-4">原题链接</h2><p><a href="https://www.acwing.com/problem/content/description/800/">https://www.acwing.com/problem/content/description/800/</a></p><h1>前缀和 &amp;&amp; 差分</h1><h2 id="一维前缀和-差分">一维前缀和&amp;&amp;差分</h2><h3 id="前缀和">前缀和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum[i]=a[1]+a[2]+a[3].....a[i];</span><br></pre></td></tr></table></figure><p><img src="https://pic2.latewind.cn/2021/04/27/00749047afae1.png" alt="D_U`EECRERK5K~XX_SOHEVG.png"></p><p>可以根据以上结果推出公式<code>a[n] = a[n-1] + a[n]</code></p><h3 id="差分">差分</h3><p>差分就是前缀和的逆运算。关系如下</p><p>如果 前缀和可以表示为f(x)=d 查分就是d=f(x)</p><p>具体看以下推理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a数组： a1, a2, a3, …, an</span><br><span class="line"></span><br><span class="line">b数组：b1, b2, b3, …, bn</span><br><span class="line"></span><br><span class="line">**a数组是b数组的前缀和**</span><br><span class="line"></span><br><span class="line">a1 = b1;</span><br><span class="line">a2 = b1 + b2;</span><br><span class="line">a3 = b1 + b2 + b3;</span><br><span class="line"></span><br><span class="line">**a数组是b数组的前缀和**</span><br><span class="line"></span><br><span class="line">那么我们来看b=啥</span><br><span class="line"></span><br><span class="line">a[0]= 0;</span><br><span class="line"></span><br><span class="line">b[1] = a[1] - a[0];</span><br><span class="line"></span><br><span class="line">b[2] = a[2] - a[1];</span><br><span class="line"></span><br><span class="line">b[3] =a [3] - a[2];</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">b[n] = a[n] - a[n-1];</span><br><span class="line"></span><br><span class="line">… .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b(n) = a(n) - a(n-1) ----&gt; an = b1 + b2 + b3 + … + bn</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>前缀和的差分=原序列</li><li>差分的前缀和=原序列</li><li><img src="https://pic2.latewind.cn/2021/04/27/05e6c8eff63b7.png" alt="~92_ZLFC4176R_@IPX_BC28.png"></li><li>所谓差分就是进行逆运算，让原数组成为新数组的前缀和，从而创造新数组。</li><li>所谓前缀和就是在这个数之前的数 和 这个数相加的总和，被称为前缀和。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">核心部分</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + 1] -= c;</span><br></pre></td></tr></table></figure><h2 id="二维矩阵-前缀和-差分">二维矩阵 前缀和 &amp;&amp; 差分</h2><h3 id="矩阵前缀和">矩阵前缀和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">核心部分</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic2.latewind.cn/2021/04/27/500ed9a60a9fd.png" alt="_KW_DN_5MODI__BI2@_29A6.png"></p><ul><li>如图所示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">核心部分</span><br><span class="line">s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];</span><br><span class="line"></span><br><span class="line">计算的是x1，y1到x2，y2的每个数的和</span><br><span class="line"></span><br><span class="line">s[x2,y2] - s[x1-1,y2] - s[x2,y1-1] + s[x1-1, y1-1]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="矩阵差分">矩阵差分</h3><p><img src="https://pic2.latewind.cn/2021/04/27/e6d1be1445ec1.png" alt="EZVQKMP@__N_J6BPXIZNQ_C.png"></p><ul><li><p>b[x1][ y1 ] +=c ; 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。</p></li><li><p>b[x1,][y2+1]-=c ; 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。</p></li><li><p>b[x2+1][y1]- =c ; 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。</p></li><li><p>b[x2+1][y2+1]+=c; 对应图4,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">自个儿推</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">核心部分</span><br><span class="line">b[i][j]+=a[i][j];</span><br><span class="line">b[i+1][j]-=a[i][j];</span><br><span class="line">b[i][j+1]-=a[i][j];</span><br><span class="line">b[i+1][j+1]+=a[i][j];</span><br></pre></td></tr></table></figure><h1>相关题目</h1><ul><li>全部来自于acwing</li></ul><h2 id="前缀和-2">前缀和</h2><p>输入一个长度为 n的整数序列。</p><p>接下来再输入 m<br>个询问，每个询问输入一对 l,r。</p><p>对于每个询问，输出原序列中从第 l<br>个数到第 r个数的和。</p><p>输入格式<br><br/><br/><br/><br>第一行包含两个整数 n 和 m。</p><p>第二行包含 n个整数，表示整数数列。</p><p>接下来 m<br>行，每行包含两个整数 l 和 r，表示一个询问的区间范围</p><br/><p>输出格式</p><p>共 m行，每行输出一个询问的结果。<br>数据范围</p><p>1≤l≤r≤n,</p><p>1≤n,m≤100000,</p><p>−1000≤数列中元素的值≤1000</p><p>输入样例：</p><p>5 3</p><p>2 1 3 6 4</p><p>1 2</p><p>1 3</p><p>2 4</p><p>输出样例：</p><p>3</p><p>6</p><p>10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5+10;</span><br><span class="line">int a[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,m;</span><br><span class="line">  int l,r;</span><br><span class="line">  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">  for(int i = 1;i &lt;= n;i ++)</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">  for(int i = 1; i &lt;= n;i ++)</span><br><span class="line">    a[i] = a[i-1] + a[i];</span><br><span class="line"></span><br><span class="line">  // //测试</span><br><span class="line">  // for(int i = 1;i &lt;= n;i ++)</span><br><span class="line">  //   printf(&quot;%d &quot;,a[i]);</span><br><span class="line">  // puts(&quot;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  while(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    printf(&quot;%d\n&quot;,a[r]-a[l-1]);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵前缀和-2">矩阵前缀和</h2><p>输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</p><br/>对于每个询问输出子矩阵中所有数的和。输入格式<br/>第一行包含三个整数 n，m，q。<p>接下来 n行，每行包含 m个整数，表示整数矩阵。</p><p>接下来 q行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。<br>输出格式<br><br/></p><p>共 q行，每行输出一个询问的结果。<br>数据范围</p><p>1≤n,m≤1000</p><p>1≤q≤200000,</p><p>1≤x1≤x2≤n,</p><p>1≤y1≤y2≤m,</p><p>−1000≤矩阵内元素的值≤1000</p><p>输入样例：</p><p>3 4 3</p><p>1 7 2 4</p><p>3 6 2 8</p><p>2 1 2 3</p><p>1 1 2 2</p><p>2 1 3 4</p><p>1 3 3 4</p><p>输出样例：</p><p>17</p><p>27</p><p>21</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line">int a[N][N],s[N][N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,m,q;</span><br><span class="line">  scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);</span><br><span class="line">  for(int i = 1;i &lt;= n ;i++)</span><br><span class="line">    for(int j = 1;j &lt;= m;j ++)</span><br><span class="line">      scanf(&quot;%d&quot;,&amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">  for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    for(int j = 1;j &lt;= m;j ++)</span><br><span class="line">      s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];</span><br><span class="line"></span><br><span class="line">  while(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    int x1,x2,y1,y2;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">    printf(&quot;%d\n&quot;,s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分-2">差分</h2><p>输入一个长度为 n的整数序列。</p><p>接下来输入 m个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。</p><p>请你输出进行完所有操作后的序列。<br>输入格式</p><p>第一行包含两个整数 n<br>和 m。</p><p>第二行包含 n个整数，表示整数序列。</p><p>接下来 m行，每行包含三个整数 l，r，c，表示一个操作。<br>输出格式</p><p>共一行，包含 n个整数，表示最终序列。</p><p>数据范围</p><p>1≤n,m≤100000</p><p>1≤l≤r≤n,</p><p>−1000≤c≤1000,</p><p>−1000≤整数序列中元素的值≤1000</p><p>输入样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">3 5 1</span><br><span class="line">1 6 1</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 3 4 2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5+10;</span><br><span class="line">int a[N];</span><br><span class="line">int b[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,m;</span><br><span class="line">  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">  for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">  //构造差分数组b1=a1,b2=a2-a1,b[n]=a[n]-a[n-1];</span><br><span class="line">  for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    b[i]=a[i]-a[i-1];</span><br><span class="line"></span><br><span class="line">    //看链接 https://www.acwing.com/solution/content/26588/</span><br><span class="line">  while(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    int l,r,c;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+1]-=c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //把差分数组还原成原数组</span><br><span class="line">  for(int i = 1;i &lt;= n;i ++)</span><br><span class="line">    b[i]+=b[i-1];</span><br><span class="line"></span><br><span class="line">  for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    printf(&quot;%d &quot;,b[i]);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵差分-2">矩阵差分</h2><p>输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。</p><p>每个操作都要将选中的子矩阵中的每个元素的值加上 c。</p><p>请你将进行完所有操作后的矩阵输出。</p><p>输入格式</p><p>第一行包含整数 n,m,q。</p><p>接下来 n行，每行包含 m个整数，表示整数矩阵。</p><p>接下来 q行，每行包含 5 个整数 x1,y1,x2,y2,c，表示一个操作。</p><p>输出格式</p><p>共 n行，每行 m个整数，表示所有操作进行完毕后的最终矩阵。</p><p>数据范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1≤n,m≤1000,</span><br><span class="line">1≤q≤100000,</span><br><span class="line">1≤x1≤x2≤n,</span><br><span class="line">1≤y1≤y2≤m,</span><br><span class="line">−1000≤c≤1000,</span><br><span class="line">−1000≤矩阵内元素的值≤1000</span><br></pre></td></tr></table></figure><p>输入样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 2 1</span><br><span class="line">3 2 2 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 2 2 1</span><br><span class="line">1 3 2 3 2</span><br><span class="line">3 1 3 4 1</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3 4 1</span><br><span class="line">4 3 4 1</span><br><span class="line">2 2 2 2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 5010;</span><br><span class="line">int a[N][N],b[N][N];</span><br><span class="line">void insert(int x1,int y1,int x2,int y2,int c)</span><br><span class="line">&#123;</span><br><span class="line">  b[x1][y1] += c;</span><br><span class="line">  b[x1][y2+1] -= c;</span><br><span class="line">  b[x2+1][y1] -= c;</span><br><span class="line">  b[x2+1][y2+1] += c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int n,m,q;</span><br><span class="line"></span><br><span class="line">  //输入</span><br><span class="line">  scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);</span><br><span class="line"></span><br><span class="line">  for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    for(int j = 1;j &lt;= m;j++)</span><br><span class="line">      scanf(&quot;%d&quot;,&amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">  //根据公式计算查分数组</span><br><span class="line">  for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    for(int j = 1;j &lt;= m;j++)</span><br><span class="line">      insert(i,j,i,j,a[i][j]);</span><br><span class="line"></span><br><span class="line">  //对差分数组进行+c操作</span><br><span class="line">  while(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    int x1,y1,x2,y2,c;</span><br><span class="line">    scanf(&quot;%d%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">    insert(x1,y1,x2,y2,c);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //转换成a数组，由差分数组，求前缀和</span><br><span class="line">  for(int i = 1; i &lt;= n;i ++)</span><br><span class="line">    for(int j = 1; j &lt;= m;j ++)</span><br><span class="line">      b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];</span><br><span class="line"></span><br><span class="line">  //输出</span><br><span class="line">  for(int i = 1; i &lt;= n;i ++)</span><br><span class="line">  &#123;</span><br><span class="line">    for(int j = 1; j &lt;= m;j ++)</span><br><span class="line">      printf(&quot;%d &quot;,b[i][j]);</span><br><span class="line">  puts(&quot;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;原题链接-4&quot;&gt;原题链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/description/800/&quot;&gt;https://www.acwing.com/problem/content/d</summary>
      
    
    
    
    
    <category term="算法,ACM" scheme="https://www.impdx.vip/tags/%E7%AE%97%E6%B3%95-ACM/"/>
    
  </entry>
  
  <entry>
    <title>AcWing 788. 逆序对的数量 &amp;&amp; 图解</title>
    <link href="https://www.impdx.vip/posts/70b1/"/>
    <id>https://www.impdx.vip/posts/70b1/</id>
    <published>2021-07-22T13:03:56.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="原题链接-3">原题链接</h2><p><a href="https://www.acwing.com/problem/content/description/790/">https://www.acwing.com/problem/content/description/790/</a></p><p><a href="https://pic2.latewind.cn/2021/04/21/78754c0e75bf0.png"><img src="https://pic2.latewind.cn/2021/04/21/78754c0e75bf0.png" alt="逆序对.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int q[N],tmp[N];</span><br><span class="line"></span><br><span class="line">LL merge_sort(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">  if(l &gt;= r) return 0;</span><br><span class="line"></span><br><span class="line">  int mid = l + r &gt;&gt; 1;</span><br><span class="line">  LL res = merge_sort(l, mid) + merge_sort(mid+1, r);</span><br><span class="line"></span><br><span class="line">  //归并</span><br><span class="line">  int k = 0,i = l,j = mid + 1;</span><br><span class="line">  while(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    if(q[i] &lt;= q[j]) tmp[k ++] = q[i ++];</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      tmp[k ++] = q[j ++];</span><br><span class="line">      //res是逆序对的数量，请看画图。</span><br><span class="line">      res += mid - i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // 把剩下的数扔进tmp</span><br><span class="line">  while(i &lt;= mid) tmp[k ++] = q[i ++];</span><br><span class="line">  while(j &lt;= r) tmp[k ++] = q[j ++];</span><br><span class="line"></span><br><span class="line">  //替换原序列</span><br><span class="line">  for(int i=l,j=0;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line"></span><br><span class="line">  //返回逆序对的数量</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">    cin &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; merge_sort(0, n-1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;原题链接-3&quot;&gt;原题链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/description/790/&quot;&gt;https://www.acwing.com/problem/content/d</summary>
      
    
    
    
    
    <category term="算法,ACM" scheme="https://www.impdx.vip/tags/%E7%AE%97%E6%B3%95-ACM/"/>
    
  </entry>
  
  <entry>
    <title>AcWing 165. 小猫爬山 c++ 思路&amp;&amp;注释</title>
    <link href="https://www.impdx.vip/posts/a659/"/>
    <id>https://www.impdx.vip/posts/a659/</id>
    <published>2021-07-22T13:01:03.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="原题链接">原题链接</h2><p><a href="https://www.acwing.com/problem/content/description/167/">https://www.acwing.com/problem/content/description/167/</a></p><h1>思路</h1><h2 id="想法">想法</h2><p>1.排序优化 //可略过，不加也可以ac</p><p>2.让猫坐满一辆车</p><p>3.开新的车</p><p>4.重复2-3</p><h2 id="具体代码思路（2-3步骤）">具体代码思路（2-3步骤）</h2><p>1.确定参数  (int u(第几只猫),int k(第几辆车))</p><p>2.跳出条件 (u==n) 当猫走完时，跳出，n为总得猫数量，已经枚举完最后一个猫了。所以跳出，为什么是u==n，因为数组是从0开始的，最后一个猫为n-1。</p><p>3.判断当前这只猫，<strong>简称u猫</strong>(判断u猫能不能放在之前的车中)</p><ul><li><p>for循环,枚举第一辆车到现在所有的车</p></li><li><p>如果可以放得下u猫，则进入新的dfs（u+1,k）</p></li><li><p>(u+1,k),</p></li></ul><blockquote><p>可以放得下猫所以车辆数不变,k就不变，u猫被放进去了，下一只猫就是u+1猫。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;k;i++)</span><br><span class="line">//从第一辆车开始遍历，遍历到k辆车，如果可以塞下第u只猫则执行；</span><br><span class="line">&#123;</span><br><span class="line">  if(a[u]+car[i]&lt;=w)</span><br><span class="line">  &#123;</span><br><span class="line">    car[i]+=a[u];</span><br><span class="line">    dfs(u+1,k);</span><br><span class="line">    car[i]-=a[u];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果放不下猫，则开一辆新车dfs(u+1,k+1)</li></ul><blockquote><p>dfs(下一只猫，下一辆车)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">car[k]=a[u];</span><br><span class="line">dfs(u+1,k+1);</span><br><span class="line">car[k]=0;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这里回溯为什么是car[k]=0,因为没放猫时，车的重量是0</li></ul><hr><h1>代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,w,ans=20;</span><br><span class="line">int a[20],car[20];</span><br><span class="line"></span><br><span class="line">int cmp(int a,int b)    //从大到小 函数sort第三个参数</span><br><span class="line">&#123;</span><br><span class="line">  return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dfs(int u,int k)</span><br><span class="line">&#123;</span><br><span class="line">  if(k&gt;=ans) return;        //注意等于ans可以减少时间，不加等于号800多ms，加了20多ms</span><br><span class="line">  if(u==n)          //u个猫等于n个猫，猫坐完车的时候</span><br><span class="line">  &#123;</span><br><span class="line">    ans=k;          </span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">//-----------------------------------start</span><br><span class="line">  for(int i=0;i&lt;k;i++)  //从第一辆车开始遍历，遍历到k辆车，如果可以塞下第u只猫则执行；</span><br><span class="line">  &#123;</span><br><span class="line">    if(a[u]+car[i]&lt;=w)</span><br><span class="line">    &#123;</span><br><span class="line">      car[i]+=a[u];</span><br><span class="line">      dfs(u+1,k);</span><br><span class="line">      car[i]-=a[u];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">//-------------------------------------end</span><br><span class="line">  //开新车</span><br><span class="line">  car[k]=a[u];</span><br><span class="line">  dfs(u+1,k+1);</span><br><span class="line">  car[k]=0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//---------输入----------</span><br><span class="line">  scanf(&quot;%d%d&quot;,&amp;n,&amp;w);</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">//---------排序优化----------</span><br><span class="line">  sort(a,a+n,cmp);</span><br><span class="line">//---------------------------------</span><br><span class="line">  dfs(0,0);</span><br><span class="line"></span><br><span class="line">  printf(&quot;%d&quot;,ans);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;原题链接&quot;&gt;原题链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/description/167/&quot;&gt;https://www.acwing.com/problem/content/des</summary>
      
    
    
    
    <category term="笔记" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法,ACM" scheme="https://www.impdx.vip/tags/%E7%AE%97%E6%B3%95-ACM/"/>
    
  </entry>
  
  <entry>
    <title>AcWing 24. 机器人的运动范围 C++ dfs(附上思路与思考&amp;&amp;注释)</title>
    <link href="https://www.impdx.vip/posts/51e9/"/>
    <id>https://www.impdx.vip/posts/51e9/</id>
    <published>2021-07-22T12:51:35.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<hr><h1>请注意：本文只包含dfs的内容 /如有错误或者意见，欢迎留言</h1><ul><li>总体思路</li></ul><blockquote><p>模拟机器人走路，在符合条件的情况下，上下左右走，走到符合条件的格子，标记/累加。走完即可。</p></blockquote><ul><li>条件的判定</li></ul><blockquote><p>1.越界情况，x，y的值得在符合二维数组范围的情况下进行<br>2.走过的点，不需要累加/标记<br>3.x,y坐标相加是否大于k的时</p></blockquote><ul><li>dfs参数选择</li></ul><blockquote><p>最近看到一条定理：一直在变化的数，就可以用于dfs的参数。<br>这里我选择了，x,y坐标的值作为dfs的参数</p></blockquote><ul><li>小思考（没有尝试过，成功的小伙伴留言一下下）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是否可以直接遍历出x,y相加的值，</span><br><span class="line">记录于二维数组中，</span><br><span class="line">从而直接得出答案(没试过)；</span><br><span class="line">提示：不能直接判断哦，看清楚上下左右；</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int k,row,col;          //row代表行，col代表列</span><br><span class="line">int n;  //用于答案计数</span><br><span class="line">int a[100][100];  </span><br><span class="line">    int movingCount(int threshold, int rows, int cols)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(a,0,sizeof(a));</span><br><span class="line">        k=threshold,row=rows,col=cols;</span><br><span class="line">        dfs(0,0);</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    int he(int x,int y) //用于计算x，y的和(题意中的和)</span><br><span class="line">    &#123;</span><br><span class="line">      int res=0;</span><br><span class="line">      while(x)</span><br><span class="line">      &#123;</span><br><span class="line">        res+=x%10;</span><br><span class="line">        x/=10;</span><br><span class="line">      &#125;</span><br><span class="line">      while(y)</span><br><span class="line">      &#123;</span><br><span class="line">        res+=y%10;</span><br><span class="line">        y/=10;</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(int x,int y)</span><br><span class="line">    &#123;</span><br><span class="line">      if(x&lt;0||y&lt;0||x&gt;=row||y&gt;=col) return;  //边界判定</span><br><span class="line">      if(a[x][y]==1) return;  //是否已经走过这个点</span><br><span class="line">      if(he(x,y)&gt;k) return;   //如果x+y大于k的话（不符合条件）</span><br><span class="line">      //剩下的符合条件的情况 的操作</span><br><span class="line">      a[x][y]=1;</span><br><span class="line">      n++;</span><br><span class="line">      dfs(x-1,y); //上</span><br><span class="line">      dfs(x+1,y); //下</span><br><span class="line">      dfs(x,y-1); //左</span><br><span class="line">      dfs(x,y+1); //右</span><br><span class="line"></span><br><span class="line">      return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1&gt;请注意：本文只包含dfs的内容 /如有错误或者意见，欢迎留言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;总体思路&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;模拟机器人走路，在符合条件的情况下，上下左右走，走到符合条件的格子，标记/累加。走完即可。&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="笔记" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法,ACM" scheme="https://www.impdx.vip/tags/%E7%AE%97%E6%B3%95-ACM/"/>
    
  </entry>
  
  <entry>
    <title>linux gcc与c for win的不同</title>
    <link href="https://www.impdx.vip/posts/5eaf/"/>
    <id>https://www.impdx.vip/posts/5eaf/</id>
    <published>2020-10-27T15:17:43.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<h1>gcc 要求</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a, &amp;b) != EOF)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int-main">int main:</h3><h3 id="while-scanf">while(scanf()):</h3><h3 id="return-0">return 0:</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;gcc 要求&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c语言可爱的运算符</title>
    <link href="https://www.impdx.vip/posts/6399/"/>
    <id>https://www.impdx.vip/posts/6399/</id>
    <published>2020-10-27T15:03:27.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<h3 id="仅为个人笔记（随笔，后期可能会整理）">仅为个人笔记（随笔，后期可能会整理）</h3><h2 id="算术运算符；">算术运算符；</h2><ul><li><p>±/* 我就不介绍了</p></li><li><p>%余数运算符，整除后的余数<br>B%A 将得到 3</p></li></ul><h1>i++与++i</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> i,a;<span class="comment">//定义i，a俩个变量</span></span><br><span class="line"> i=<span class="number">5</span>;</span><br><span class="line"> a=<span class="number">0</span>; <span class="comment">//赋值俩个变量</span></span><br><span class="line"> a=i++; <span class="comment">//进行i++运算</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i); <span class="comment">// 打印输出i，这里的i无论是i++还是++i，都会+1</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a); <span class="comment">//表示整个i++式子的变量</span></span><br><span class="line"></span><br><span class="line"> i=<span class="number">5</span>;</span><br><span class="line"> a=<span class="number">0</span>;</span><br><span class="line"> a=++i;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line"> i=<span class="number">5</span>;</span><br><span class="line"> a=<span class="number">0</span>;</span><br><span class="line"> a=--i;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line"> i=<span class="number">5</span>;</span><br><span class="line"> a=<span class="number">0</span>;</span><br><span class="line"> a=i--;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>变量名++；    // 表示在本次使用变量后再自增；<br>++变量名;     // 表示在本次使用变量前自增；<br>变量名–；    // 表示在本次使用变量后再自增；<br>–变量名;     // 表示在本次使用变量前自减；</p></blockquote><ul><li><p>其实很简单，无论是i++还是++i，i这个变量一定会变，那么i++与++i有什么不同呢？</p></li><li><p>i++这个式子的值还是i，++i式子的值是i+1，不同的是式子的值</p></li></ul><h2 id="赋值运算符">赋值运算符</h2><p><strong>字符串（字符数组）不能使用赋值运算符。</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>A=B</td></tr><tr><td>+=</td><td>A+=B;A=A+B</td></tr><tr><td>-=</td><td>A-=B;A=A-B</td></tr><tr><td>*=</td><td>A*=B;A=A*B</td></tr><tr><td>/=</td><td>A/=B;A=A/B</td></tr><tr><td>%=</td><td>A%=B;A=A%B</td></tr></tbody></table><h2 id="sizeof运算符；">sizeof运算符；</h2><ul><li><p>sizeof是C语言的关键字，它用来计算变量（或数据类型）在当前系统中占用内存的字节数。</p></li><li><p>sizeof不是函数，产生这样的疑问是因为sizeof的书写确实有点像函数，sizeof有两种写法：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof(数据类型);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>俩种写法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d&quot;,sizeof(a)); //输出a的占用字节数</span><br><span class="line">printf(&quot;%d&quot;,sizeof a ); //对于变量也可以不加括号</span><br><span class="line">printf(&quot;%d&quot;,sizeof(int)); //输出4，对于数据类型，必须加括号</span><br><span class="line"></span><br><span class="line">个人建议全部加括号</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关系运算符；">关系运算符；</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==  =</span><br><span class="line">&lt;=  ≤</span><br><span class="line">&gt;=  ≥</span><br><span class="line">&gt;   大于</span><br><span class="line">&lt;   小于</span><br><span class="line">这些不多说了</span><br></pre></td></tr></table></figure><ul><li>!= 表示不等于</li></ul><h2 id="逻辑运算符；">逻辑运算符；</h2><ul><li>在 c语言中，三个逻辑运算符，与vb，python稍微不同，意思一样，写法不同</li></ul><h3 id="与">&amp;&amp; (与)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;<span class="number">-1</span> &amp;&amp; a&lt;<span class="number">0</span>)  <span class="comment">//表示只有满足俩个条件时才继续运行</span></span><br></pre></td></tr></table></figure><h3 id="（或）">||（或）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;<span class="number">-1</span> || a&lt;<span class="number">0</span>)  <span class="comment">//表示满足其中一个条件时才继续运行</span></span><br></pre></td></tr></table></figure><h3 id="（非）">!（非）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(a&gt;<span class="number">-1</span>))  <span class="comment">//表示不满足此条件时运行</span></span><br></pre></td></tr></table></figure><h2 id="位运算符。">位运算符。</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;仅为个人笔记（随笔，后期可能会整理）&quot;&gt;仅为个人笔记（随笔，后期可能会整理）&lt;/h3&gt;
&lt;h2 id=&quot;算术运算符；&quot;&gt;算术运算符；&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;±/* 我就不介绍了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;%余数运算符，整除后的余数&lt;br&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网站 更新日志</title>
    <link href="https://www.impdx.vip/posts/ee22/"/>
    <id>https://www.impdx.vip/posts/ee22/</id>
    <published>2020-07-22T13:10:44.000Z</published>
    <updated>2023-08-24T06:56:16.755Z</updated>
    
    <content type="html"><![CDATA[<hr><p>此文章仅作为网站更新日志</p><h1>列表</h1><ul><li><p>2022.1.23</p><ul><li>update<ul><li>更新butterfly4.0.1版本</li><li>根据config修改了CDN</li><li>twikoo版本更新</li></ul></li><li>fix<ul><li>图片无法显示问题</li><li>twikoo 显示错误</li></ul></li></ul></li><li><p>2021.7.22 22:33</p><ul><li>修改又拍云配置，禁用云储存，申请又拍云联盟代金卷</li><li>增加https://impdx.vercel.app/ 托管至vercel</li></ul></li><li><p>2021.7.22</p><ul><li>从hexo4.2切换到hexo5.4</li><li>从butterfly2.8更新至3.8.2</li><li>更新nodejs版本</li><li>去除coding的托</li><li>去除三家cdn混用，引入又拍云cdn并同步至又拍云储存</li><li>去除aplayer吸顶音乐</li><li>更新各种插件版本<ul><li>hexo-abbrlink</li><li>hexo-baidu-url-submit</li><li>hexo-filter-nofollow</li><li>hexo-generator-baidu-sitemap</li><li>hexo-generator-sitemap</li><li>hexo-renderer-markdown-it</li><li>hexo-offline</li><li>@neilsustc/markdown-it-katex</li><li>hexo-generator-feed</li></ul></li></ul></li><li><p>2020年 太久远了 没有记录哦^_^</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;此文章仅作为网站更新日志&lt;/p&gt;
&lt;h1&gt;列表&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2022.1.23&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;update
&lt;ul&gt;
&lt;li&gt;更新butterfly4.0.1版本&lt;/li&gt;
&lt;li&gt;根据config修改了CDN&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="笔记" scheme="https://www.impdx.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="hexo" scheme="https://www.impdx.vip/tags/hexo/"/>
    
  </entry>
  
</feed>
